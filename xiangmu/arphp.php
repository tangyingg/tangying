<?php 
/** ArPHP generate one file
 *  @author ycassnr ycassnr@gmail.com
 */
 class ArException extends Exception { }
 defined('AR_START_TIME') or define('AR_START_TIME', microtime(true)); defined('AR_DEBUG') or define('AR_DEBUG', true); defined('AR_OUTER_START') or define('AR_OUTER_START', false); defined('AR_AUTO_START_SESSION') or define('AR_AUTO_START_SESSION', true); defined('AR_AS_OUTER_FRAME') or define('AR_AS_OUTER_FRAME', false); defined('AR_RUN_AS_SERVICE_HTTP') or define('AR_RUN_AS_SERVICE_HTTP', false); defined('AR_AS_CMD') or define('AR_AS_CMD', false); defined('AR_AS_WEB') or define('AR_AS_WEB', true); defined('AR_DEFAULT_APP_NAME') or define('AR_DEFAULT_APP_NAME', 'main'); defined('AR_DEFAULT_CONTROLLER') or define('AR_DEFAULT_CONTROLLER', 'Index'); defined('AR_DEFAULT_ACTION') or define('AR_DEFAULT_ACTION', 'index'); defined('DS') or define('DS', DIRECTORY_SEPARATOR); defined('AR_FRAME_PATH') or define('AR_FRAME_PATH', dirname(__FILE__) . DS); defined('AR_ROOT_PATH') or define('AR_ROOT_PATH', realpath(dirname($_SERVER['SCRIPT_FILENAME'])) . DS); defined('AR_CORE_PATH') or define('AR_CORE_PATH', AR_FRAME_PATH . 'Core' . DS); defined('AR_CONFIG_PATH') or define('AR_CONFIG_PATH', AR_FRAME_PATH . 'Conf' . DS); defined('AR_EXT_PATH') or define('AR_EXT_PATH', AR_FRAME_PATH . 'Extensions' . DS); defined('AR_COMP_PATH') or define('AR_COMP_PATH', AR_FRAME_PATH . 'Components' . DS); defined('AR_SERVER_PATH') or define('AR_SERVER_PATH', ($dir = dirname($_SERVER['SCRIPT_NAME'])) == DS ? '/' : str_replace(DS, '/', $dir) . '/'); defined('AR_PUBLIC_CONFIG_FILE') or define('AR_PUBLIC_CONFIG_FILE', '');  spl_autoload_register('Ar::autoLoader'); if (AR_OUTER_START) : defined('AR_MAN_NAME') or define('AR_MAN_NAME', 'Arman'); defined('AR_MAN_PATH') or define('AR_MAN_PATH', AR_ROOT_PATH . AR_MAN_NAME . DS); elseif (AR_AS_CMD) : defined('AR_CMD_PATH') or define('AR_CMD_PATH', AR_ROOT_PATH . AR_DEFAULT_APP_NAME . DS); else : set_exception_handler('Ar::exceptionHandler'); set_error_handler('Ar::errorHandler'); register_shutdown_function('Ar::shutDown'); endif; Ar::init(); 
 class ArComponent { protected $config = array(); static public function init($config = array(), $class = __CLASS__) { $obj = new $class; if ($config) : $obj->config = $config; endif; return $obj; } public function setConfig($config = array()) { $this->config = $config; } public function getConfig($ckey = '') { $rt = ''; if ($ckey) : if (!empty($this->config[$ckey])) : $rt = $this->config[$ckey]; endif; else : $rt = $this->config; endif; return $rt; } } 
 abstract class ArCache extends ArComponent { abstract function get($key); abstract function set($key, $value); abstract function del($key); abstract function flush(); protected function generateUniqueKey($keyName) { return md5($keyName); } protected function encrypt($data) { return serialize($data); } protected function decrypt($data) { return unserialize($data); } } 
 class ArFile extends ArCache { public $cachePath; static public function init($config = array(), $class = __CLASS__) { $obj = parent::init($config, $class); $obj->cachePath = empty($obj->config['cachePath']) ? arCfg('PATH.CACHE') : $obj->config['cachePath']; if(!is_dir($obj->cachePath)) : mkdir($obj->cachePath, 0777, true); endif; return $obj; } public function cacheFile($key) { return $this->cachePath . $this->generateUniqueKey($key) . '.cache'; } public function get($key) { $cacheFile = $this->cacheFile($key); if (is_file($cacheFile)) : if ($this->checkExpire($cacheFile)) : $data = null; $this->del($key); $data = null; else : $data = $this->decrypt(file_get_contents($cacheFile, false, null, 10)); endif; else : $data = null; endif; return $data; } public function set($key, $value, $expire = 0) { if ($expire == 0) : $timeExpire = '0000000000'; else : $timeExpire = time() + $expire; endif; return file_put_contents($this->cacheFile($key), $timeExpire . $this->encrypt($value)); } public function del($key) { $cacheFile = $this->cacheFile($key); if (is_file($cacheFile)) : unlink($cacheFile); endif; return true; } public function checkExpire($file) { $timeExpire = file_get_contents($file, false, null, 0, 10); return $timeExpire == 0 ? false : ($timeExpire < time()); } public function flush($force = false, $dir = '') { $cachePath = $dir ? $dir : $this->cachePath; if (is_dir($cachePath)) : $source = opendir($cachePath); while ($file = readdir($source)) : $file = $cachePath . $file; if (is_file($file)) : if ($force || $this->checkExpire($file)) : unlink($file); endif; endif; endwhile; closedir($source); endif; } public function flushAll($force = true, $module = array()) { if (empty($module)) : $module = arCfg('moduleLists'); endif; foreach ($module as $dir) : $dir = AR_ROOT_PATH . $dir . DS . 'Cache' . DS; $this->flush($force, $dir); endforeach; } } 
 class ArRedis extends ArCache { private $_redis = null; static public function init($config = array(), $class = __CLASS__) { $obj = parent::init($config, $class); $obj->connect(); return $obj; } public function connect($reConnect = false) { if (!$this->_redis || $reConnect) : $this->_redis = new Redis(); if (isset($this->config['pconnect']) && $this->config['pconnect'] === true) : $this->_redis->pconnect($this->config['host'], $this->config['port'], 2); else : $this->_redis->connect($this->config['host'], $this->config['port'], 2); endif; if (!$this->_redis->IsConnected() && !$reConnect) : throw new ArException('Failed to connect to redis: redis server went away'); else : if(!empty($this->config['password'])) : $this->_redis->auth($this->config['password']); endif; if (!empty($this->config['db'])) : $this->_redis->select($this->config['db']); endif; endif; endif; } public function reConnect() { $this->connect(true); sleep(1); } private $lockedNames = array(); public function lock($name, $timeout = 0, $expire = 6, $waitIntervalUs = 100000) { if(empty($name)) return false; $timeout = (int)$timeout; $expire = max((int)$expire, 5); $redisKey = "Lock:$name"; while (true) { $now = microtime(true); $timeoutAt = $now + $timeout; $expireAt = $now + $expire; $result = $this->redis()->setnx($redisKey, (string)$expireAt); if ($result !== false) : $this->redis()->expire($redisKey, $expire); $this->lockedNames[$name] = $expireAt; return true; endif; $ttl = $this->redis()->ttl($redisKey); if ($ttl < 0) : $this->redis()->set($redisKey, (string)$expireAt, $expire); $this->lockedNames[$name] = $expireAt; return true; endif; if($timeout <= 0 || microtime(true) > $timeoutAt) break; usleep($waitIntervalUs); } return false; } public function expire($name, $expire) { if ($this->isLocking($name)) : if ($this->redis()->expire("Lock:$name", max($expire, 1))) : return true; endif; endif; return false; } public function isLocking($name) { if (isset($this->lockedNames[$name])) : return (string)$this->lockedNames[$name] == (string)$this->redis()->get("Lock:$name"); endif; return false; } public function unlock($name) { if ($this->isLocking($name)) : if ($this->redis()->del("Lock:$name")) : unset($this->lockedNames[$name]); return true; endif; endif; return false; } public function unlockAll() { $allSuccess = true; foreach ($this->lockedNames as $name => $item) : if (false === $this->unlock($name)) : $allSuccess = false; endif; endforeach; return $allSuccess; } public function redis() { while ($this->_redis->IsConnected() === false) : echo 'c false'; $this->reConnect(); endwhile; return $this->_redis; } public function generateUniqueKey($key) { return $key; } public function get($key) { try { $value = $this->redis()->get($this->generateUniqueKey($key)); if (is_scalar($value)) : if (strpos($value, '[') === 0 || strpos($value, '{') === 0) : return json_decode($value, true); else : return $value; endif; else : return false; endif; } catch (Exception $e) { arComp('list.log')->record($key, 'rsexception:' . __FUNCTION__); return null; } } public function set($key, $value, $expire = 0) { if (is_array($value)) : $value = json_encode($value); endif; if ($expire > 0) : return (bool)$this->redis()->set($this->generateUniqueKey($key), $value, $expire); else : return (bool)$this->redis()->set($this->generateUniqueKey($key), $value); endif; } public function incr($key, $start = 0) { if ($start > 0) : return $this->redis()->incrBy($this->generateUniqueKey($key), $start); else : return $this->redis()->incr($this->generateUniqueKey($key)); endif; } public function exists($key) { return $this->redis()->exists($this->generateUniqueKey($key)); } public function del($key) { return (bool)$this->redis()->del($this->generateUniqueKey($key)); } public function flush() { return $this->redis()->flushDB(); } public function flushAll() { return $this->redis()->flushAll(); } } 
 class ArDb extends ArComponent { static public $readConnections = array(); static public $writeConnections = array(); static public $dbHolder = array(); public $connectionMark = 'read.default'; protected $pdoStatement = null; protected $driverName = 'PDO'; public function read($name = 'default', $returnPdoConnection = false) { $connectionMark = 'read.' . $name; if (empty($this->config['read']['default'])) : $tempCk = array_keys($this->config['read']); $fistrKey = array_shift($tempCk); $this->config['read']['default'] = $this->config['read'][$fistrKey]; endif; if (!isset(self::$readConnections[$name]) && isset($this->config['read'][$name])) : self::addReadConnection($name); endif; if (!isset(self::$readConnections[$name])) : throw new ArDbException('dbReadConfig not hava a param ' . $name, 1); endif; if ($returnPdoConnection) : return self::$readConnections[$name]; else : if (!isset(self::$dbHolder[$connectionMark])) : $newDbHolder = clone $this; $newDbHolder->connectionMark = $connectionMark; self::$dbHolder[$connectionMark] = $newDbHolder; endif; return self::$dbHolder[$connectionMark]; endif; } public function write($name = 'default', $returnPdoConnection = false) { $this->connectionMark = 'write.' . $name; if (!isset(self::$writeConnections[$name]) && isset($this->config['write'][$name])) : self::addWriteConnection($name); endif; if (!isset(self::$writeConnections[$name])) : throw new ArDbException('dbWriteConfig not hava a param ' . $name, 1); endif; if ($returnPdoConnection) : return self::$writeConnections[$name]; else : if (!isset(self::$dbHolder[$connectionMark])) : $newDbHolder = clone $this; $newDbHolder->connectionMark = $connectionMark; self::$dbHolder[$connectionMark] = $newDbHolder; endif; return self::$dbHolder[$connectionMark]; endif; } protected function addConnection($mark, $update = false) { list($dataBaseType, $name) = explode('.', $mark); if ($dataBaseType == 'read') : return $this->addReadConnection($name, $update); else : return $this->addWriteConnection($name, $update); endif; } protected function addReadConnection($name = '', $update = false) { if (!isset(self::$readConnections[$name]) || $update) : self::$readConnections[$name] = $this->createConnection('read.' . $name, $update); endif; return self::$readConnections[$name]; } protected function addWriteConnection($name = '', $update = false) { if (!isset(self::$writeConnections[$name]) || $update) : self::$writeConnections[$name] = $this->createConnection('write.' . $name, $update); endif; return self::$writeConnections[$name]; } protected function createConnection($name = '', $reConnect = false) { list($dataBaseType, $mark) = explode('.', $name); $dsn = $this->config[$dataBaseType][$mark]['dsn']; $user = $this->config[$dataBaseType][$mark]['user']; $pass = $this->config[$dataBaseType][$mark]['pass']; $option = $this->config[$dataBaseType][$mark]['option']; try { return new $this->driverName($dsn, $user, $pass, $option); } catch (PDOException $e) { if ($reConnect === true) : if ((strpos($e->getMessage(), 'Lost connection to MySQL server') !== false) || (strpos($e->getMessage(), 'server has gone away') !== false)) : sleep(1); return $this->createConnection($name, true); endif; endif; throw $e; } } protected function getCurrentConfig($configKey = '') { list($dataBaseType, $mark) = explode('.', $this->connectionMark); if (empty($this->config[$dataBaseType][$mark])) : throw new ArDbException("Db Config Mark Error : " . $this->connectionMark . ' Required'); endif; if (empty($configKey)) : return $this->config[$dataBaseType][$mark]; else : if (array_key_exists($configKey, $this->config[$dataBaseType][$mark])) : return $this->config[$dataBaseType][$mark][$configKey]; else : throw new ArDbException("Db Config Lost Key Error : " . $configKey . ' Required'); endif; endif; } protected function getDbConnection() { if (empty($this->connectionMark) || !strpos($this->connectionMark, '.')) : throw new ArDbException("Connection Mark Error : " . $this->connectionMark); endif; list($dataBaseType, $mark) = explode('.', $this->connectionMark); switch ($dataBaseType) { case 'read': return $this->read($mark, true); break; case 'write': return $this->write($mark, true); break; default: throw new ArDbException("Connection Mark DataBase Type Error : " . $this->connectionMark); break; } } public function setPdoAttributes($attribute , $value = '') { $this->getDbConnection()->setAttribute($attribute, $value); return $this; } public function transBegin() { return $this->getDbConnection()->beginTransaction(); } public function transCommit() { return $this->getDbConnection()->commit(); } public function transRollBack() { return $this->getDbConnection()->rollBack(); } public function inTransaction() { return $this->getDbConnection()->inTransaction(); } public function __clone() { $this->connectionMark = ''; } } 
 class ArMssql extends ArDb { public $lastSql = ''; public $lastInsertId = ''; public $allowGuessConditionOperator = true; protected $options = array( 'columns' => '*', 'table' => '', 'join' => '', 'where' => '', 'group' => '', 'having' => '', 'order' => '', 'limit' => '', 'union' => '', 'comment' => '', ); protected function flushOptions() { $this->options = array( 'columns' => '*', 'table' => '', 'join' => '', 'where' => '', 'group' => '', 'having' => '', 'order' => '', 'limit' => '', 'union' => '', 'comment' => '', ); return true; } public function query($sql = '') { static $i = array(); $returnResult = false; if (empty($sql)) : $sql = $this->buildSelectSql(); else : $returnResult = true; endif; $sqlCmd = strtoupper(substr($sql, 0, 6)); if(in_array($sqlCmd, array('UPDATE', 'DELETE')) && stripos($sql, 'where') === false) : throw new ArDbException('no WHERE condition in SQL(UPDATE, DELETE) to be executed! please make sure it\'s safe', 42005); endif; $this->lastSql = $sql; $this->flushOptions(); try { $this->pdoStatement = $this->getDbConnection()->query($sql); $i[] = $this->pdoStatement; } catch (PDOException $e) { throw new ArDbException($e->getMessage() . ' lastsql :' . $sql); } if ($returnResult) : return $this->pdoStatement->fetchAll(PDO::FETCH_ASSOC); endif; return $this->pdoStatement; } public function getColumns() { $table = $this->options['table']; $sql = 'show columns from ' . $table; $ret = $this->query($sql)->fetchAll(PDO::FETCH_ASSOC); $columns = array(); foreach ($ret as $value) : $columns[] = $value['Field']; endforeach; return $columns; } public function count() { $result = $this->select(array('COUNT(\'*\') as t'))->queryRow(); if (empty($result)) : $total = 0; else : $total = (int)$result['t']; endif; return $total; } public function queryRow() { $this->limit(1); return $this->query()->fetch(PDO::FETCH_ASSOC); } public function queryColumn($field = '') { if ($result = $this->select($field)->queryRow()) : $result = $result[$field]; endif; return $result; } public function queryAll($columnKey = '') { $result = $this->query()->fetchAll(PDO::FETCH_ASSOC); if ($result && $columnKey) : $dataBox = array(); foreach ($result as $row) : if (isset($row[$columnKey])) : $dataBox[$row[$columnKey]] = $row; endif; endforeach; $result = $dataBox; endif; return $result; } public function setSource($source) { $this->options['source'] = $source; return $this; } public function insert(array $data = array(), $checkData = false) { $options = $this->options; if (ArModel::model($this->options['source'])->insertCheck($data)) : $data = ArModel::model($this->options['source'])->formatData($data); if (!empty($data)) : if ($checkData) : $data = arComp('format.format')->filterKey($this->getColumns(), $data); endif; $this->options = $options; $this->data($data); else : return false; endif; $sql = $this->bulidInsertSql(); $this->exec($sql); return $this->lastInsertId = $this->getDbConnection()->lastInsertId(); endif; return false; } public function update(array $data = array(), $checkData = false) { $options = $this->options; if ($checkData) : $data = arComp('format.format')->filterKey($this->getColumns(), $data); unset($data['id']); endif; $this->options = $options; if (!empty($data)) : $this->columns($data); endif; $sql = $this->bulidUpdateSql(); return $this->exec($sql); } public function delete() { $sql = $this->buildDeleteSql(); if (!preg_match('/ WHERE /i', $sql)) : throw new ArDbException('bad sql condition , where must to be infix'); endif; return $this->exec($sql); } protected function exec($sql) { try { $this->lastSql = $sql; $this->flushOptions(); return $this->getDbConnection()->exec($sql); } catch (PDOException $e) { throw new ArDbException($e->getMessage() . ' lastsql :' . $sql); } } protected function quote($data) { if (is_array($data) || is_object($data)) : $return = array(); foreach ($data as $k => $v) : $return[$k] = $this->quote($v); endforeach; return $return; else : $data = $this->getDbConnection()->quote($data); if (false === $data) : $data = "''"; endif; return $data; endif; } public function select($fields = '') { if (is_string($fields) && strpos($fields, ',')) : $fields = explode(',', $fields); endif; if (is_array($fields)) : $array = array(); foreach ($fields as $key => $field) : if (!is_numeric($key)) : $array[] = $this->quoteObj($key) . ' AS ' . $this->quoteObj($field); else : $array[] = $this->quoteObj($field); endif; endforeach; $fieldsStr = implode(',', $array); elseif (is_string($fields) && !empty($fields)) : $fieldsStr = $this->quoteObj($fields); else : $fieldsStr = '*'; endif; $this->options['columns'] = $fieldsStr; return $this; } public function table($table) { $this->options['table'] = $this->quoteObj($this->getCurrentConfig('prefix') . $table); return $this; } public function join($table, $cond) { return $this->joinInternal('JOIN', $table, $cond); } public function leftJoin($table, $cond) { return $this->joinInternal('LEFT JOIN', $table, $cond); } public function rightJoin($table, $cond) { return $this->joinInternal('RIGHT JOIN', $table, $cond); } protected function joinInternal($join, $table, $cond) { $table = $this->quoteObj($table); $this->options['join'] .= " $join $table "; if (is_string($cond) && (strpos($cond, '=') === false && strpos($cond, '<') === false && strpos($cond, '>') === false)) : $column = $this->quoteObj($cond); $this->options['join'] .= " USING ($column) "; else : $cond = $this->buildCondition($cond); $this->options['join'] .= " ON $cond "; endif; return $this; } public function quoteObj($objName) { return $objName; if (is_array($objName)) : $return = array(); foreach ( $objName as $k => $v ) : $return[] = $this->quoteObj($v); endforeach; return $return; else : $v = trim($objName); $v = str_replace('`', '', $v); $v = preg_replace('# +AS +| +#i', ' ', $v); $v = explode(' ', $v); foreach ($v as $k_1 => $v_1) : $v_1 = trim($v_1); if ($v_1 == '') : unset($v[$k_1]); continue; endif; if (strpos($v_1, '.')) : $v_1 = explode('.', $v_1); foreach ($v_1 as $k_2 => $v_2) : if ($v_2 != '*') : $v_1[$k_2] = '`' . trim($v_2) . '`'; else : $v_1[$k_2] = trim($v_2); endif; endforeach; $v[$k_1] = implode('.', $v_1); elseif (preg_match('#\(.+\)#', $v_1)) : $v[$k_1] = $v_1; else : $v[$k_1] = '`'.$v_1.'`'; endif; endforeach; $v = implode(' AS ', $v); return $v; endif; } public function group($group) { $this->options['group'] = empty($group) ? '' : ' GROUP BY ' . $group; return $this; } public function having($having) { $this->options['having'] = empty($having) ? '' : ' HAVING ' . $having; return $this; } public function where($conditions = '') { $conStr = $this->buildCondition($conditions); $this->options['where'] = empty($conStr) ? '' : ' WHERE ' . $conStr; return $this; } public function order($order) { $this->options['order'] = empty($order) ? '' : ' ORDER BY ' . $order; return $this; } public function limit($limit) { $this->options['limit'] = empty($limit) ? '' : ' TOP ' . $limit; return $this; } public function union($union) { } public function columns($data) { $setStr = ''; if (is_string($data)) : $setStr = $data; elseif (is_array($data)) : foreach ($data as $key => $val) : $set[] = $this->quoteObj($key) . '=' . $this->quote($val); endforeach; $setStr = implode(',', $set); endif; $this->options['set'] = ' SET ' . $setStr; return $this; } public function data(array $data) { $values = $fields = array(); foreach ($data as $key => $val) : if(is_scalar($val) || is_null($val)) : $fields[] = $this->quoteObj($key); $values[] = $this->quote($val); endif; endforeach; $this->options['data'] = '(' . implode($fields, ',') . ') VALUES (' . implode($values, ',') . ')'; return $this; } public function buildCondition($condition = array(), $logic = 'AND') { if (!is_array($condition)) : if (is_string($condition)) : $count = preg_match('#\>|\<|\=| #', $condition, $logic); if (!$count) : throw new ArDbException('bad sql condition: must be a valid sql condition'); endif; $condition = explode($logic[0], $condition); $condition[0] = $this->quoteObj($condition[0]); $condition = implode($logic[0], $condition); return $condition; endif; throw new ArDbException('bad sql condition: ' . gettype($condition)); endif; $logic = strtoupper($logic); $content = null; foreach ($condition as $k => $v) : $v_str = null; $v_connect = ''; if (is_int($k)) : if ($content) : $content .= $logic . ' (' . $this->buildCondition($v) . ') '; else : $content = '(' . $this->buildCondition($v) . ') '; endif; continue; endif; $k = trim($k); $maybe_logic = strtoupper($k); if (in_array($maybe_logic, array('AND', 'OR'))) : if ($content) : $content .= $logic . ' (' . $this->buildCondition($v, $maybe_logic) . ') '; else : $content = '(' . $this->buildCondition($v, $maybe_logic) . ') '; endif; continue; endif; $k_upper = strtoupper($k); $maybe_connectors = array('>=', '<=', '<>', '!=', '>', '<', '=', ' NOT BETWEEN', ' BETWEEN', 'NOT LIKE', ' LIKE', ' IS NOT', ' NOT IN', ' IS', ' IN'); foreach ($maybe_connectors as $maybe_connector) : $l = strlen($maybe_connector); if (substr($k_upper, -$l) == $maybe_connector) : $k = trim(substr($k, 0, -$l)); $v_connect = $maybe_connector; break; endif; endforeach; if (is_null($v)) : $v_str = ' NULL'; if ($v_connect == '') : $v_connect = 'IS'; endif; elseif (is_array($v)) : if ($v_connect == ' BETWEEN') : $v_str = $this->quote($v[0]) . ' AND ' . $this->quote($v[1]); elseif (is_array($v) && !empty($v)) : $v_str = null; foreach ($v AS $one) : if (is_array($one)) : $sub_items = ''; foreach ($one as $sub_value) : $sub_items .= ',' . $this->quote($sub_value); endforeach; $v_str .= ',(' . substr($sub_items, 1) . ')' ; else : $v_str .= ',' . $this->quote($one); endif; endforeach; $v_str = '(' . substr($v_str, 1) . ')'; if (empty($v_connect)) : if ($this->allowGuessConditionOperator === null || $this->allowGuessConditionOperator === true) : $v_connect = 'IN'; else : throw new ArDbException("guessing condition operator is not allowed: use '$k IN'=>array(...)"); endif; endif; elseif (empty($v)) : $v_str = $k; $v_connect = '<>'; endif; else : $v_str = $this->quote($v); endif; if (empty($v_connect)) : $v_connect = '='; endif; $quoted_k = $this->quoteObj($k); if ($content) : $content .= " $logic ( $quoted_k $v_connect $v_str ) "; else : $content = " ($quoted_k $v_connect $v_str) "; endif; endforeach; return $content; } protected function buildSelectSql() { $sql = str_replace( array('%TABLE%','%COLUMNS%','%JOIN%','%WHERE%','%GROUP%','%HAVING%','%ORDER%','%LIMIT%','%UNION%','%COMMENT%'), array( $this->options['table'], $this->options['columns'], $this->options['join'], $this->options['where'], $this->options['group'], $this->options['having'], $this->options['order'], $this->options['limit'], $this->options['union'], $this->options['comment'] ), 'SELECT %LIMIT% %COLUMNS% FROM %TABLE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER%%UNION%%COMMENT%' ); return $sql; } protected function bulidUpdateSql() { $sql = str_replace( array('%TABLE%','%SET%','%WHERE%','%COMMENT%'), array( $this->options['table'], $this->options['set'], $this->options['where'], $this->options['comment'] ), 'UPDATE %TABLE%%SET%%WHERE%%COMMENT%' ); return $sql; } protected function bulidInsertSql() { $sql = str_replace( array('%TABLE%','%DATA%','%COMMENT%'), array( $this->options['table'], $this->options['data'], $this->options['comment'] ), 'INSERT INTO %TABLE%%DATA%%COMMENT%' ); return $sql; } public function buildDeleteSql($options = array()) { $sql = str_replace( array('%TABLE%', '%WHERE%', '%COMMENT%'), array( $this->options['table'], $this->options['where'], $this->options['comment'] ), 'DELETE FROM %TABLE%%WHERE%%COMMENT%' ); return $sql; } public function __toString() { return var_export(get_class_methods(__CLASS__), 1); } } 
 class ArMysql extends ArDb { public $lastSql = ''; public $lastInsertId = ''; public $allowGuessConditionOperator = true; public $cacheEnabled; public $cacheTime; public $cacheType; protected $options = array( 'columns' => '*', 'table' => '', 'join' => '', 'where' => '', 'group' => '', 'having' => '', 'order' => '', 'limit' => '', 'union' => '', 'comment' => '', 'source' => 'ArModel', ); protected function flushOptions() { $this->options = array( 'columns' => '*', 'table' => '', 'join' => '', 'where' => '', 'group' => '', 'having' => '', 'order' => '', 'limit' => '', 'union' => '', 'comment' => '', ); return true; } protected function query($sql = '') { static $i = array(); if (empty($sql)) : $sql = $this->buildSelectSql(); endif; $sqlCmd = strtoupper(substr($sql, 0, 6)); if(in_array($sqlCmd, array('UPDATE', 'DELETE')) && stripos($sql, 'where') === false) : throw new ArDbException('no WHERE condition in SQL(UPDATE, DELETE) to be executed! please make sure it\'s safe', 42005); endif; $this->lastSql = $sql; $this->flushOptions(); try { $connection = $this->getDbConnection(); $this->pdoStatement = $connection->query($sql); } catch (PDOException $e) { if ((strpos($e->getMessage(), 'Lost connection to MySQL server') !== false) || (strpos($e->getMessage(), 'server has gone away') !== false)) : $connection = null; $connection = $this->addConnection($this->connectionMark, true); $this->pdoStatement = $connection->query($sql); else : throw new ArDbException($e->getMessage() . ' lastsql :' . $sql); endif; } return $this->pdoStatement; } public function sqlQuery($sql = '') { if (empty($sql)) : throw new ArDbException("Query Sql String Should Not Be Empty"); endif; $ret = $this->query($sql)->fetchAll(PDO::FETCH_ASSOC); return $ret; } public function sqlExec($sql = '') { return $this->exec($sql); } public function getColumns() { $connectionMark = $this->connectionMark; $table = $this->options['table']; $sql = 'show columns from ' . $table; $ret = $this->query($sql)->fetchAll(PDO::FETCH_ASSOC); $columns = array(); foreach ($ret as $value) : $columns[] = $value['Field']; endforeach; $this->connectionMark = $connectionMark; return $columns; } public function count() { $result = $this->select(array('COUNT(\'*\') as t'))->queryRow(); if (empty($result)) : $total = 0; else : $total = (int)$result['t']; endif; return $total; } public function queryRow() { $this->limit(1); $sql = $this->buildSelectSql(); $this->flushOptions(); if ($this->cacheEnabled) : $cacheKey = $this->cacheType . $sql; $cacheResult = arComp('cache.' . $this->cacheType)->get($cacheKey); if ($cacheResult !== null) : $this->cacheEnabled = false; return $cacheResult; endif; endif; $result = $this->query($sql)->fetch(PDO::FETCH_ASSOC); if ($this->cacheEnabled) : $this->cacheEnabled = false; $cacheKey = $this->cacheType . $sql; arComp('cache.' . $this->cacheType)->set($cacheKey, $result, $this->cacheTime); endif; return $result; } public function queryColumn($field = '') { if ($result = $this->select($field)->queryRow()) : $result = $result[$field]; endif; return $result; } public function queryAll($columnKey = '') { $sql = $this->buildSelectSql(); $this->flushOptions(); if ($this->cacheEnabled) : $cacheKey = $this->cacheType . $sql; $cacheResult = arComp('cache.' . $this->cacheType)->get($cacheKey); if ($cacheResult !== null) : $this->cacheEnabled = false; return $cacheResult; endif; endif; $result = $this->query($sql)->fetchAll(PDO::FETCH_ASSOC); if ($result && $columnKey) : $dataBox = array(); foreach ($result as $row) : if (isset($row[$columnKey])) : $dataBox[$row[$columnKey]] = $row; endif; endforeach; $result = $dataBox; endif; if ($this->cacheEnabled) : $this->cacheEnabled = false; $cacheKey = $this->cacheType . $sql; arComp('cache.' . $this->cacheType)->set($cacheKey, $result, $this->cacheTime); endif; return $result; } public function cache($time = 0, $type = 'file') { $this->cacheEnabled = true; $this->cacheTime = $time; $this->cacheType = $type; return $this; } public function setSource($source) { $this->options['source'] = $source; return $this; } public function insert(array $data = array(), $checkData = false) { if (empty($this->options['source'])) : $this->options['source'] = 'ArModel'; endif; $options = $this->options; if (ArModel::model($this->options['source'])->insertCheck($data)) : $data = ArModel::model($this->options['source'])->formatData($data); if (!empty($data)) : $this->options = $options; if ($checkData) : $data = arComp('format.format')->filterKey($this->getColumns(), $data); endif; $this->options = $options; $this->data($data); else : return false; endif; $sql = $this->bulidInsertSql(); $rtstatus = $this->exec($sql); $this->lastInsertId = $this->getDbConnection()->lastInsertId(); return $this->lastInsertId ? $this->lastInsertId : $rtstatus; endif; return false; } public function batchInsert(array $data = array()) { $options = $this->options; $this->data($data, true); $sql = $this->bulidInsertSql(); $this->options = $options; $rtstatus = $this->exec($sql); $this->lastInsertId = $this->getDbConnection()->lastInsertId(); return $this->lastInsertId ? $this->lastInsertId : $rtstatus; } public function update(array $data = array(), $checkData = false) { $options = $this->options; if ($checkData) : $data = arComp('format.format')->filterKey($this->getColumns(), $data); unset($data['id']); endif; $this->options = $options; if (!empty($data)) : $this->columns($data); endif; $sql = $this->bulidUpdateSql(); return $this->exec($sql); } public function delete() { $sql = $this->buildDeleteSql(); if (!preg_match('/ WHERE /i', $sql)) : throw new ArDbException('bad sql condition , where must to be infix'); endif; return $this->exec($sql); } protected function exec($sql = '') { if (empty($sql)) : throw new ArDbException("Exec Sql String Should Not Be Empty"); endif; try { $this->lastSql = $sql; $this->flushOptions(); $connection = $this->getDbConnection(); $rt = $connection->exec($sql); } catch (PDOException $e) { if ((strpos($e->getMessage(), 'Lost connection to MySQL server') !== false) || (strpos($e->getMessage(), 'server has gone away') !== false)) : $connection = null; $connection = $this->addConnection($this->connectionMark, true); $rt = $connection->exec($sql); else : throw new ArDbException($e->getMessage() . ' lastsql :' . $sql); endif; } return $rt; } protected function quote($data) { if (is_array($data) || is_object($data)) : $return = array(); foreach ($data as $k => $v) : $return[$k] = $this->quote($v); endforeach; return $return; else : $data = $this->getDbConnection()->quote($data); if (false === $data) : $data = "''"; endif; return $data; endif; } public function select($fields = '') { if (is_string($fields) && strpos($fields, ',')) : $fields = explode(',', $fields); endif; if (is_array($fields)) : $array = array(); foreach ($fields as $key => $field) : if (!is_numeric($key)) : $array[] = $this->quoteObj($key) . ' AS ' . $this->quoteObj($field); else : $array[] = $this->quoteObj($field); endif; endforeach; $fieldsStr = implode(',', $array); elseif (is_string($fields) && !empty($fields)) : $fieldsStr = $this->quoteObj($fields); else : $fieldsStr = '*'; endif; $this->options['columns'] = $fieldsStr; return $this; } public function selectDistinct($distinctfield = '', $columns = '') { if ($distinctfield) : if (!$columns) : $this->select($columns); $this->options['columns'] = 'distinct ' . $this->quoteObj($distinctfield) . ',' . $this->options['columns']; else : $this->options['columns'] = 'distinct ' . $this->quoteObj($distinctfield); endif; endif; return $this; } public function table($table) { $this->options['table'] = $this->quoteObj($this->getCurrentConfig('prefix') . $table); return $this; } public function join($table, $cond) { return $this->joinInternal('JOIN', $table, $cond); } public function leftJoin($table, $cond) { return $this->joinInternal('LEFT JOIN', $table, $cond); } public function rightJoin($table, $cond) { return $this->joinInternal('RIGHT JOIN', $table, $cond); } protected function joinInternal($join, $table, $cond) { $table = $this->quoteObj($table); $this->options['join'] .= " $join $table "; if (is_string($cond) && (strpos($cond, '=') === false && strpos($cond, '<') === false && strpos($cond, '>') === false)) : $column = $this->quoteObj($cond); $this->options['join'] .= " USING ($column) "; else : $cond = $this->buildCondition($cond); $this->options['join'] .= " ON $cond "; endif; return $this; } public function quoteObj($objName) { if (is_array($objName)) : $return = array(); foreach ( $objName as $k => $v ) : $return[] = $this->quoteObj($v); endforeach; return $return; else : $v = trim($objName); $v = str_replace('`', '', $v); $v = preg_replace('# +AS +| +#i', ' ', $v); $v = explode(' ', $v); foreach ($v as $k_1 => $v_1) : $v_1 = trim($v_1); if ($v_1 == '') : unset($v[$k_1]); continue; endif; if (strpos($v_1, '.')) : $v_1 = explode('.', $v_1); foreach ($v_1 as $k_2 => $v_2) : if ($v_2 != '*') : $v_1[$k_2] = '`' . trim($v_2) . '`'; else : $v_1[$k_2] = trim($v_2); endif; endforeach; $v[$k_1] = implode('.', $v_1); elseif (preg_match('#\(.+\)#', $v_1)) : $v[$k_1] = $v_1; elseif ($v_1 === '*') : $v[$k_1] = $v_1; else : $v[$k_1] = '`'.$v_1.'`'; endif; endforeach; $v = implode(' AS ', $v); return $v; endif; } public function group($group) { $this->options['group'] = empty($group) ? '' : ' GROUP BY ' . $group; return $this; } public function having($having) { $this->options['having'] = empty($having) ? '' : ' HAVING ' . $having; return $this; } public function where($conditions = '', $logic = 'AND') { $conStr = $this->buildCondition($conditions, $logic); $this->options['where'] = empty($conStr) ? '' : ' WHERE ' . $conStr; return $this; } public function order($order) { $this->options['order'] = empty($order) ? '' : ' ORDER BY ' . $order; return $this; } public function limit($limit) { $this->options['limit'] = empty($limit) ? '' : ' LIMIT ' . $limit; return $this; } public function union($union) { } public function columns($data) { $setStr = ''; if (is_string($data)) : $setStr = $data; elseif (is_array($data)) : foreach ($data as $key => $val) : $set[] = $this->quoteObj($key) . '=' . $this->quote($val); endforeach; $setStr = implode(',', $set); endif; $this->options['set'] = ' SET ' . $setStr; return $this; } public function data(array $data, $batch = false) { $values = $fields = array(); if (!$batch) : foreach ($data as $key => $val) : if(is_scalar($val) || is_null($val)) : $fields[] = $this->quoteObj($key); $values[] = $this->quote($val); endif; endforeach; $this->options['data'] = '(' . implode($fields, ',') . ') VALUES (' . implode($values, ',') . ')'; else : $fields = array_keys($data[0]); $valueString = ''; foreach ($data as $key => $value) : $valueBundle = array(); foreach ($value as $val) : if(is_scalar($val) || is_null($val)) : $valueBundle[] = $this->quote($val); endif; endforeach; if ($valueString) : $valueString .= ',(' . implode($valueBundle, ',') . ')'; else : $valueString .= '(' . implode($valueBundle, ',') . ')'; endif; endforeach; $this->options['data'] = '(' . implode($fields, ',') . ') VALUES ' . $valueString; endif; return $this; } public function buildCondition($condition = array(), $logic = 'AND') { if (!is_array($condition)) : if (is_string($condition)) : $count = preg_match('#\>|\<|\=| #', $condition, $logic); if (!$count) : throw new ArDbException('bad sql condition: must be a valid sql condition'); endif; return $condition; endif; throw new ArDbException('bad sql condition: ' . gettype($condition)); endif; $logic = strtoupper($logic); $content = null; foreach ($condition as $k => $v) : $v_str = null; $v_connect = ''; if (is_int($k)) : if ($content) : $content .= $logic . ' (' . $this->buildCondition($v) . ') '; else : $content = '(' . $this->buildCondition($v) . ') '; endif; continue; endif; $k = trim($k); $maybe_logic = strtoupper($k); if (in_array($maybe_logic, array('AND', 'OR'))) : if ($content) : $content .= $logic . ' (' . $this->buildCondition($v, $maybe_logic) . ') '; else : $content = '(' . $this->buildCondition($v, $maybe_logic) . ') '; endif; continue; endif; $k_upper = strtoupper($k); $maybe_connectors = array('>=', '<=', '<>', '!=', '>', '<', '=', ' NOT BETWEEN', ' BETWEEN', 'NOT LIKE', ' LIKE', ' IS NOT', ' NOT IN', ' IS', ' IN'); foreach ($maybe_connectors as $maybe_connector) : $l = strlen($maybe_connector); if (substr($k_upper, -$l) == $maybe_connector) : $k = trim(substr($k, 0, -$l)); $v_connect = $maybe_connector; break; endif; endforeach; if (is_null($v)) : $v_str = ' NULL'; if ($v_connect == '') : $v_connect = 'IS'; endif; elseif (is_array($v)) : if ($v_connect == ' BETWEEN') : $v_str = $this->quote($v[0]) . ' AND ' . $this->quote($v[1]); elseif (is_array($v) && !empty($v)) : $v_str = null; foreach ($v AS $one) : if (is_array($one)) : $sub_items = ''; foreach ($one as $sub_value) : $sub_items .= ',' . $this->quote($sub_value); endforeach; $v_str .= ',(' . substr($sub_items, 1) . ')' ; else : $v_str .= ',' . $this->quote($one); endif; endforeach; $v_str = '(' . substr($v_str, 1) . ')'; if (empty($v_connect)) : if ($this->allowGuessConditionOperator === null || $this->allowGuessConditionOperator === true) : $v_connect = 'IN'; else : throw new ArDbException("guessing condition operator is not allowed: use '$k IN'=>array(...)"); endif; endif; elseif (empty($v)) : $v_str = $k; $v_connect = '<>'; endif; else : $v_str = $this->quote($v); endif; if (empty($v_connect)) : $v_connect = '='; endif; $quoted_k = $this->quoteObj($k); if ($content) : $content .= " $logic ( $quoted_k $v_connect $v_str ) "; else : $content = " ($quoted_k $v_connect $v_str) "; endif; endforeach; return $content; } protected function buildSelectSql() { $sql = str_replace( array('%TABLE%','%COLUMNS%','%JOIN%','%WHERE%','%GROUP%','%HAVING%','%ORDER%','%LIMIT%','%UNION%','%COMMENT%'), array( $this->options['table'], $this->options['columns'], $this->options['join'], $this->options['where'], $this->options['group'], $this->options['having'], $this->options['order'], $this->options['limit'], $this->options['union'], $this->options['comment'] ), 'SELECT %COLUMNS% FROM %TABLE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER%%LIMIT% %UNION%%COMMENT%' ); return $sql; } protected function bulidUpdateSql() { $sql = str_replace( array('%TABLE%','%SET%','%WHERE%','%COMMENT%'), array( $this->options['table'], $this->options['set'], $this->options['where'], $this->options['comment'] ), 'UPDATE %TABLE%%SET%%WHERE%%COMMENT%' ); return $sql; } protected function bulidInsertSql() { $sql = str_replace( array('%TABLE%','%DATA%','%COMMENT%'), array( $this->options['table'], $this->options['data'], $this->options['comment'] ), 'INSERT INTO %TABLE%%DATA%%COMMENT%' ); return $sql; } public function buildDeleteSql($options = array()) { $sql = str_replace( array('%TABLE%', '%WHERE%', '%COMMENT%'), array( $this->options['table'], $this->options['where'], $this->options['comment'] ), 'DELETE FROM %TABLE%%WHERE%%COMMENT%' ); return $sql; } public function __toString() { return var_export(get_class_methods(__CLASS__), 1); } } 
 class ArOracle extends ArDb { public $lastSql = ''; public $lastInsertId = ''; public $allowGuessConditionOperator = true; protected $options = array( 'columns' => '*', 'table' => '', 'join' => '', 'where' => '', 'group' => '', 'having' => '', 'order' => '', 'limit' => '', 'union' => '', 'comment' => '', ); protected function flushOptions() { $this->options = array( 'columns' => '*', 'table' => '', 'join' => '', 'where' => '', 'group' => '', 'having' => '', 'order' => '', 'limit' => '', 'union' => '', 'comment' => '', ); return true; } protected function query($sql = '') { static $i = array(); if (empty($sql)) : $sql = $this->buildSelectSql(); endif; $sqlCmd = strtoupper(substr($sql, 0, 6)); if(in_array($sqlCmd, array('UPDATE', 'DELETE')) && stripos($sql, 'where') === false) : throw new ArDbException('no WHERE condition in SQL(UPDATE, DELETE) to be executed! please make sure it\'s safe', 42005); endif; $this->lastSql = $sql; $this->flushOptions(); try { $this->pdoStatement = $this->getDbConnection()->query($sql); $i[] = $this->pdoStatement; } catch (PDOException $e) { throw new ArDbException($e->getMessage() . ' lastsql :' . $sql); } $this->connectionMark = 'read.default'; return $this->pdoStatement; } public function sqlQuery($sql = '') { if (empty($sql)) : throw new ArDbException("Query Sql String Should Not Be Empty"); endif; $ret = $this->query($sql)->fetchAll(PDO::FETCH_ASSOC); return $ret; } public function sqlExec($sql = '') { return $this->exec($sql); } public function getColumns() { $table = $this->options['table']; $sql = 'show columns from ' . $table; $ret = $this->query($sql)->fetchAll(PDO::FETCH_ASSOC); $columns = array(); foreach ($ret as $value) : $columns[] = $value['Field']; endforeach; return $columns; } public function count() { $result = $this->select(array('COUNT(\'*\') as T'))->queryAll(); if (empty($result)) : $total = 0; else : $total = (int)$result[0]['T']; endif; return $total; } public function queryRow() { $this->limit(1); return $this->query()->fetch(PDO::FETCH_ASSOC); } public function queryColumn($field = '') { if ($result = $this->select($field)->queryRow()) : $result = $result[$field]; endif; return $result; } public function queryAll($columnKey = '') { $result = $this->query()->fetchAll(PDO::FETCH_ASSOC); if ($result && $columnKey) : $dataBox = array(); foreach ($result as $row) : if (isset($row[$columnKey])) : $dataBox[$row[$columnKey]] = $row; endif; endforeach; $result = $dataBox; endif; return $result; } public function setSource($source) { $this->options['source'] = $source; return $this; } public function insert(array $data = array(), $checkData = false) { $options = $this->options; if (ArModel::model($this->options['source'])->insertCheck($data)) : $data = ArModel::model($this->options['source'])->formatData($data); if (!empty($data)) : if ($checkData) : $data = arComp('format.format')->filterKey($this->getColumns(), $data); endif; $this->options = $options; $this->data($data); else : return false; endif; $sql = $this->bulidInsertSql(); return $this->exec($sql); endif; return false; } public function update(array $data = array(), $checkData = false) { $options = $this->options; if ($checkData) : $data = arComp('format.format')->filterKey($this->getColumns(), $data); unset($data['id']); endif; $this->options = $options; if (!empty($data)) : $this->columns($data); endif; $sql = $this->bulidUpdateSql(); return $this->exec($sql); } public function delete() { $sql = $this->buildDeleteSql(); if (!preg_match('/ WHERE /i', $sql)) : throw new ArDbException('bad sql condition , where must to be infix'); endif; return $this->exec($sql); } protected function exec($sql = '') { if (empty($sql)) : throw new ArDbException("Exec Sql String Should Not Be Empty"); endif; try { $this->lastSql = $sql; $this->flushOptions(); $rt = $this->getDbConnection()->exec($sql); $this->connectionMark = 'read.default'; return $rt; } catch (PDOException $e) { throw new ArDbException($e->getMessage() . ' lastsql :' . $sql); } } protected function quote($data) { if (is_array($data) || is_object($data)) : $return = array(); foreach ($data as $k => $v) : $return[$k] = $this->quote($v); endforeach; return $return; else : if (!preg_match("#\(.+\)#", $data)) : $data = $this->getDbConnection()->quote($data); endif; if (false === $data) : $data = "''"; endif; return $data; endif; } public function select($fields = '') { if (is_string($fields) && strpos($fields, ',')) : $fields = explode(',', $fields); endif; if (is_array($fields)) : $array = array(); foreach ($fields as $key => $field) : if (!is_numeric($key)) : $array[] = $this->quoteObj($key) . ' AS ' . $this->quoteObj($field); else : $array[] = $this->quoteObj($field); endif; endforeach; $fieldsStr = implode(',', $array); elseif (is_string($fields) && !empty($fields)) : $fieldsStr = $this->quoteObj($fields); else : $fieldsStr = '*'; endif; $this->options['columns'] = $fieldsStr; return $this; } public function table($table) { $this->options['table'] = $this->quoteObj($this->getCurrentConfig('prefix') . $table); return $this; } public function join($table, $cond) { return $this->joinInternal('JOIN', $table, $cond); } public function leftJoin($table, $cond) { return $this->joinInternal('LEFT JOIN', $table, $cond); } public function rightJoin($table, $cond) { return $this->joinInternal('RIGHT JOIN', $table, $cond); } protected function joinInternal($join, $table, $cond) { $table = $this->quoteObj($table); $this->options['join'] .= " $join $table "; if (is_string($cond) && (strpos($cond, '=') === false && strpos($cond, '<') === false && strpos($cond, '>') === false)) : $column = $this->quoteObj($cond); $this->options['join'] .= " USING ($column) "; else : $cond = $this->buildCondition($cond); $this->options['join'] .= " ON $cond "; endif; return $this; } public function quoteObj($objName) { return $objName; if (is_array($objName)) : $return = array(); foreach ( $objName as $k => $v ) : $return[] = $this->quoteObj($v); endforeach; return $return; else : $v = trim($objName); $v = str_replace('`', '', $v); $v = preg_replace('# +AS +| +#i', ' ', $v); $v = explode(' ', $v); foreach ($v as $k_1 => $v_1) : $v_1 = trim($v_1); if ($v_1 == '') : unset($v[$k_1]); continue; endif; if (strpos($v_1, '.')) : $v_1 = explode('.', $v_1); foreach ($v_1 as $k_2 => $v_2) : if ($v_2 != '*') : $v_1[$k_2] = '`' . trim($v_2) . '`'; else : $v_1[$k_2] = trim($v_2); endif; endforeach; $v[$k_1] = implode('.', $v_1); elseif (preg_match('#\(.+\)#', $v_1)) : $v[$k_1] = $v_1; else : $v[$k_1] = '`'.$v_1.'`'; endif; endforeach; $v = implode(' AS ', $v); return $v; endif; } public function group($group) { $this->options['group'] = empty($group) ? '' : ' GROUP BY ' . $group; return $this; } public function having($having) { $this->options['having'] = empty($having) ? '' : ' HAVING ' . $having; return $this; } public function where($conditions = '') { $conStr = $this->buildCondition($conditions); if ($conStr) : if ($this->options['where']) : $this->options['where'] .= ' AND ( ' . $conStr . '  ) '; else : $this->options['where'] = ' WHERE ' . $conStr; endif; endif; return $this; } public function order($order) { $this->options['order'] = empty($order) ? '' : ' ORDER BY ' . $order; return $this; } public function limit($limit) { if ($limit) : $this->where(array('ROWNUM <=' => $limit)); endif; return $this; } public function union($union) { } public function columns($data) { $setStr = ''; if (is_string($data)) : $setStr = $data; elseif (is_array($data)) : foreach ($data as $key => $val) : $set[] = $this->quoteObj($key) . '=' . $this->quote($val); endforeach; $setStr = implode(',', $set); endif; $this->options['set'] = ' SET ' . $setStr; return $this; } public function data(array $data) { $values = $fields = array(); foreach ($data as $key => $val) : if(is_scalar($val) || is_null($val)) : $fields[] = $this->quoteObj($key); $values[] = $this->quote($val); endif; endforeach; $this->options['data'] = '(' . implode($fields, ',') . ') VALUES (' . implode($values, ',') . ')'; return $this; } public function buildCondition($condition = array(), $logic = 'AND') { if (!is_array($condition)) : if (is_string($condition)) : $count = preg_match('#\>|\<|\=| #', $condition, $logic); if (!$count) : throw new ArDbException('bad sql condition: must be a valid sql condition'); endif; $condition = explode($logic[0], $condition); $condition[0] = $this->quoteObj($condition[0]); $condition = implode($logic[0], $condition); return $condition; endif; throw new ArDbException('bad sql condition: ' . gettype($condition)); endif; $logic = strtoupper($logic); $content = null; foreach ($condition as $k => $v) : $v_str = null; $v_connect = ''; if (is_int($k)) : if ($content) : $content .= $logic . ' (' . $this->buildCondition($v) . ') '; else : $content = '(' . $this->buildCondition($v) . ') '; endif; continue; endif; $k = trim($k); $maybe_logic = strtoupper($k); if (in_array($maybe_logic, array('AND', 'OR'))) : if ($content) : $content .= $logic . ' (' . $this->buildCondition($v, $maybe_logic) . ') '; else : $content = '(' . $this->buildCondition($v, $maybe_logic) . ') '; endif; continue; endif; $k_upper = strtoupper($k); $maybe_connectors = array('>=', '<=', '<>', '!=', '>', '<', '=', ' NOT BETWEEN', ' BETWEEN', 'NOT LIKE', ' LIKE', ' IS NOT', ' NOT IN', ' IS', ' IN'); foreach ($maybe_connectors as $maybe_connector) : $l = strlen($maybe_connector); if (substr($k_upper, -$l) == $maybe_connector) : $k = trim(substr($k, 0, -$l)); $v_connect = $maybe_connector; break; endif; endforeach; if (is_null($v)) : $v_str = ' NULL'; if ($v_connect == '') : $v_connect = 'IS'; endif; elseif (is_array($v)) : if ($v_connect == ' BETWEEN') : $v_str = $this->quote($v[0]) . ' AND ' . $this->quote($v[1]); elseif (is_array($v) && !empty($v)) : $v_str = null; foreach ($v AS $one) : if (is_array($one)) : $sub_items = ''; foreach ($one as $sub_value) : $sub_items .= ',' . $this->quote($sub_value); endforeach; $v_str .= ',(' . substr($sub_items, 1) . ')' ; else : $v_str .= ',' . $this->quote($one); endif; endforeach; $v_str = '(' . substr($v_str, 1) . ')'; if (empty($v_connect)) : if ($this->allowGuessConditionOperator === null || $this->allowGuessConditionOperator === true) : $v_connect = 'IN'; else : throw new ArDbException("guessing condition operator is not allowed: use '$k IN'=>array(...)"); endif; endif; elseif (empty($v)) : $v_str = $k; $v_connect = '<>'; endif; else : $v_str = $this->quote($v); endif; if (empty($v_connect)) : $v_connect = '='; endif; $quoted_k = $this->quoteObj($k); if ($content) : $content .= " $logic ( $quoted_k $v_connect $v_str ) "; else : $content = " ($quoted_k $v_connect $v_str) "; endif; endforeach; return $content; } protected function buildSelectSql() { $sql = str_replace( array('%TABLE%','%COLUMNS%','%JOIN%','%WHERE%','%GROUP%','%HAVING%','%ORDER%','%LIMIT%','%UNION%','%COMMENT%'), array( $this->options['table'], $this->options['columns'], $this->options['join'], $this->options['where'], $this->options['group'], $this->options['having'], $this->options['order'], $this->options['limit'], $this->options['union'], $this->options['comment'] ), 'SELECT %COLUMNS% FROM %TABLE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER% %UNION%%COMMENT%' ); return $sql; } protected function bulidUpdateSql() { $sql = str_replace( array('%TABLE%','%SET%','%WHERE%','%COMMENT%'), array( $this->options['table'], $this->options['set'], $this->options['where'], $this->options['comment'] ), 'UPDATE %TABLE%%SET%%WHERE%%COMMENT%' ); return $sql; } protected function bulidInsertSql() { $sql = str_replace( array('%TABLE%','%DATA%','%COMMENT%'), array( $this->options['table'], $this->options['data'], $this->options['comment'] ), 'INSERT INTO %TABLE%%DATA%%COMMENT%' ); return $sql; } public function buildDeleteSql($options = array()) { $sql = str_replace( array('%TABLE%', '%WHERE%', '%COMMENT%'), array( $this->options['table'], $this->options['where'], $this->options['comment'] ), 'DELETE FROM %TABLE%%WHERE%%COMMENT%' ); return $sql; } public function __toString() { return var_export(get_class_methods(__CLASS__), 1); } } 
 class ArOut extends ArComponent { public function json($data = array(), array $options = array()) { if (empty($options['showJson']) || $options['showJson'] == true) : if (empty($options['data'])) : $retArr = array( 'ret_code' => '1000', 'ret_msg' => '', ); if (is_array($data)) : if (!isset($data['ret_code']) || !isset($data['ret_msg'])) : $retArr['data'] = $data; $retArr['total_lines'] = Ar::c('validator.validator')->checkMutiArray($data) ? (string)count($data) : 1; $retArr = array_merge($retArr, $options); else : if (!empty($data['error_msg']) && empty($data['ret_code'])) : $retArr['ret_code'] = "1001"; endif; $retArr = array_merge($retArr, $data); endif; else : $retArr['ret_msg'] = $data; endif; else : $retArr = $data; endif; echo json_encode($retArr); else : return $data; endif; } public function deBug($msg = '', $tag = 'TRACE', $show = false) { static $deBugMsg = array(); if (!array_key_exists($tag, $deBugMsg)) : $deBugMsg[$tag] = ''; endif; if ($msg) : if (preg_match("#\[[A-Z_]+\]$#", $msg)) : $msg = "<b>" . $msg . "</b>"; else : $msg = "&nbsp;&nbsp;" . $msg; endif; $deBugMsg[$tag] .= $msg . "<br>"; endif; if ($show && !empty($deBugMsg[$tag])) : $showContentBox = array( 'header' => '<div style="width:98%;bottom:30px"><div style="border-top:1px #666 dashed;background:#f1f1f1;text-align:center;font-size:20px;margin:10px 0px 10px;">[DEBUG ' . $tag . ' INFO] </div>', 'showMsg' => '<div style="padding:5px;background:#f3f3f1;line-height:30px">' . $deBugMsg[$tag] . '</div>', 'footer' => '</div>', ); if (arCfg('DEBUG_SHOW_TRACE')) : $showContentBox['trance'] = '<div style="background:#f8f8f8">RUN TIME : ' . (microtime(1) - AR_START_TIME) . 's</div>'; endif; if (arCfg('DEBUG_LOG')) : arComp('list.log')->record($showContentBox, 'debug'); switch ($tag) { case 'EXCEPTION': Header("HTTP/1.1 404 Not Found"); arSeg(array('segKey' => 'Redirect/404')); break; case 'SERVER_ERROR': Header("HTTP/1.1 500 App Error"); arSeg(array('segKey' => 'Redirect/500')); break; default: break; } else : echo join($showContentBox, ''); endif; $deBugMsg[$tag] = ''; endif; } public function array2xml(array $array, $xml = false, $root = 'root') { if ($xml === false) : $xml = new SimpleXMLElement('<' . $root . '/>'); endif; foreach ($array as $key => $value) : if (is_array($value)) : $this->array2xml($value, $xml->addChild($key)); else : $xml->addChild($key, $value); endif; endforeach; return $xml->asXML(); } public function xml2array($xml, $trimCdata = false) { $reg = "/<(\w+)[^>]*>([\\x00-\\xFF]*)<\\/\\1>/"; if (preg_match_all($reg, $xml, $matches)) : $count = count($matches[0]); for ($i = 0; $i < $count; $i++) : $subxml = $matches[2][$i]; $key = $matches[1][$i]; if (preg_match($reg, $subxml)) : $arr[$key] = $this->xml2array($subxml, $trimCdata); else : if ($trimCdata) : $arr[$key] = str_replace(array('<![CDATA[', ']]>'), '', $subxml); else : $arr[$key] = $subxml; endif; endif; endfor; endif; return $arr; } } 
 class ArUpload extends ArComponent { public $dest = ''; public $errorMsg = null; protected $upField = ''; public function errorMsg() { return $this->errorMsg; } static public $extensionMap = array( 'img' => array( 'jpg', 'gif', 'png' ), ); public function upload($upField, $dest = '', $extension = 'all') { $this->errorMsg = null; $this->upField = $upField; if (!empty($_FILES[$this->upField]) && empty($_FILES['error']) && is_uploaded_file($_FILES[$this->upField]['tmp_name'])) : if ($extension == 'all' || $this->checkFileType($this->getFileExtensionName($_FILES[$this->upField]['name']), $extension)) : $dest = empty($dest) ? arCfg('PATH.UPLOAD') : $dest; if (!is_dir($dest)) : mkdir($dest, 0777, true); endif; $upFileName = $this->generateFileName(); $destFile = rtrim($dest, DS) . DS . $upFileName; if (move_uploaded_file($_FILES[$this->upField]['tmp_name'], $destFile)) : else : $this->errorMsg = '上传出错'; endif; endif; else : if (empty($_FILES)) : $this->errorMsg = 'empty $_FILES uploaded file maybe exceeds the upload_max_filesize(' . ini_get('upload_max_filesize') . ') directive in php.ini'; else : if (empty($_FILES[$this->upField])) : $this->errorMsg = "Filed '$upField' invalid"; else : $this->errorMsg = $this->errorcodeToMessage($_FILES[$this->upField]['error']); endif; endif; endif; if (!!$this->errorMsg) : return false; else : return $upFileName; endif; } private function errorcodeToMessage($code) { switch ($code) { case UPLOAD_ERR_INI_SIZE: $message = "The uploaded file exceeds the upload_max_filesize(" . ini_get('upload_max_filesize') . ") directive in php.ini"; break; case UPLOAD_ERR_FORM_SIZE: $message = "The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form"; break; case UPLOAD_ERR_PARTIAL: $message = "The uploaded file was only partially uploaded"; break; case UPLOAD_ERR_NO_FILE: $message = "No file was uploaded"; break; case UPLOAD_ERR_NO_TMP_DIR: $message = "Missing a temporary folder"; break; case UPLOAD_ERR_CANT_WRITE: $message = "Failed to write file to disk"; break; case UPLOAD_ERR_EXTENSION: $message = "File upload stopped by extension"; break; default: $message = "Unknown upload error"; break; } return $message; } protected function checkFileType($extension, $aExtension = 'img') { if (is_array($aExtension)) : if (!in_array($extension, $aExtension)) : $this->errorMsg ="仅支持 " . implode(',', $aExtension) . " 类型"; endif; else : if (array_key_exists($aExtension, self::$extensionMap)) : if (!in_array($extension, self::$extensionMap[$aExtension])) : $this->errorMsg = "仅支持 " . implode(',', self::$extensionMap[$aExtension]). " 类型"; endif; elseif ($extension != $aExtension) : $this->errorMsg ="仅支持{$aExtension}类型"; endif; endif; return !$this->errorMsg; } protected function generateFileName() { return md5(time() . rand()) . '.' . $this->getFileExtensionName($_FILES[$this->upField]['name']); } protected function getFileExtensionName($fileName) { return strtolower(substr($fileName, strrpos($fileName, '.') + 1)); } } 
 class ArWeixin extends ArComponent { protected $appId; protected $appSecret; protected $token; protected $rawDataArray; private static $events = array(); static public function init($config = array(), $class = __CLASS__) { $obj = parent::init($config, $class); if (empty($obj->config['APPID'])) : throw new ArException("wx config mission error : " . "'APPID' required !"); else : $obj->appId = $obj->config['APPID']; endif; if (empty($obj->config['APPSECRET'])) : throw new ArException("wx config mission error : " . "'APPSECRET' required !"); else : $obj->appSecret = $obj->config['APPSECRET']; endif; if (empty($obj->config['TOKEN'])) : throw new ArException("wx config mission error : " . "'TOKEN' required !"); else : $obj->token = $obj->config['TOKEN']; endif; arComp('rpc.api')->curlOptions = array( CURLOPT_SSL_VERIFYPEER => false, ); arComp('rpc.api')->method = 'post'; return $obj; } public function __get($name) { if (isset($this->rawDataArray[$name])) : return $this->rawDataArray[$name]; else : return null; endif; } public function upload($filePath, $type) { $postFile = array('media' => '@' . $filePath); $accessToken = $this->getAccessToken(); $result = arComp('rpc.api')->remoteCall( 'http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=' . $accessToken . '&type=' . $type, $postFile); $resultArray = $this->handlerRemoteData($result); return $resultArray; } public function send(array $news) { $accessToken = $this->getAccessToken(); $jsonNews = urldecode(json_encode(arComp('format.format')->urlencode($news))); $result = arComp('rpc.api')->remoteCall( 'https://api.weixin.qq.com/cgi-bin/message/mass/send?access_token=' . $accessToken, $jsonNews); $resultArray = $this->handlerRemoteData($result); return $resultArray; } public function uploadNews(array $news) { $articles = array(); if (arComp('validator.validator')->checkMutiArray($news)) : foreach ($news as $new) : if (count($news) == 7) : $article['thumb_media_id'] = $new[0]; $article['author'] = $new[1]; $article['title'] = $new[2]; $article['content_source_url'] = $new[3]; $article['content'] = $new[4]; $article['digest'] = $new[5]; $article['show_cover_pic'] = $new[6]; $articles['articles'][] = $article; else : throw new ArException("数组长度不对应"); endif; endforeach; else : $new = $news; if (count($new) == 7) : $article['thumb_media_id'] = $new[0]; $article['author'] = $new[1]; $article['title'] = $new[2]; $article['content_source_url'] = $new[3]; $article['content'] = $new[4]; $article['digest'] = $new[5]; $article['show_cover_pic'] = $new[6]; $articles['articles'][] = $article; else : throw new ArException("数组长度不对应"); endif; $articles['articles'][] = $article; endif; if (empty($articles)) : throw new ArException("提交数据为空"); endif; $accessToken = $this->getAccessToken(); $jsonArticles = urldecode(json_encode(arComp('format.format')->urlencode($articles))); $result = arComp('rpc.api')->remoteCall( 'https://api.weixin.qq.com/cgi-bin/media/uploadnews?access_token=' . $accessToken, $jsonArticles); $resultArray = $this->handlerRemoteData($result); return $resultArray; } public function getAccessToken() { if (!arComp('cache.file')->get('wx_token')) : $result = arComp('rpc.api')->remoteCall('https://api.weixin.qq.com/cgi-bin/token', array('grant_type' => 'client_credential', 'appid' => $this->appId, 'secret' => $this->appSecret)); $resultArray = $this->handlerRemoteData($result); arComp('cache.file')->set('wx_token', $resultArray['access_token'], '7200'); endif; return arComp('cache.file')->get('wx_token'); } public function getOpenIdList() { $accessToken = $this->getAccessToken(); $result = arComp('rpc.api')->remoteCall('https://api.weixin.qq.com/cgi-bin/user/get?' . 'access_token=' . $accessToken); $resultArray = $this->handlerRemoteData($result); return $resultArray; } public function getJsTicket() { if (!arComp('cache.file')->get('wx_jsticket')) : $accessToken = $this->getAccessToken(); $result = arComp('rpc.api')->remoteCall('https://api.weixin.qq.com/cgi-bin/ticket/getticket?type=jsapi&' . 'access_token=' . $accessToken); $resultArray = $this->handlerRemoteData($result); arComp('cache.file')->set('wx_jsticket', $resultArray['ticket'], $resultArray['expires_in']); endif; return arComp('cache.file')->get('wx_jsticket'); } public function createMenu() { if (empty($this->config['menu'])) : throw new ArException("wx config mission error : " . "'menu' required !"); endif; $jsonPostMenu = urldecode(json_encode(arComp('format.format')->urlencode($this->config['menu']))); $result = arComp('rpc.api')->remoteCall('https://api.weixin.qq.com/cgi-bin/menu/create?access_token=' . $this->getAccessToken(), $jsonPostMenu); $resultArray = $this->handlerRemoteData($result); return $resultArray; } public function handlerRemoteData($data = '') { if ($data = json_decode($data, true)) : if (!empty($data['errcode'])) : throw new ArException("wx request error : " . $data['errmsg'] . ', code : ' . $data['errcode']); else : return $data; endif; else : throw new ArException("wx data parse error , data : " . $data); endif; } private function checkSignature() { if (!empty($this->config['notCheckSign'])) : return true; endif; $signature = arGet('signature'); $timestamp = arGet('timestamp'); $nonce = arGet('nonce'); $token = $this->token; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if ($tmpStr == $signature) : arComp('list.log')->record('sign check true'); return true; else : arComp('list.log')->record('sign check false'); return false; endif; } public function response($type = 'text', $data = array()) { $result = call_user_func_array(array($this, 'process' . ucfirst($type)), array($data)); arComp('list.log')->record($result); echo $result; } public function listen() { if ($this->checkSignature()) : $this->processWxServerRequest(); $eventName = strtolower($this->rawDataArray['Event']); arComp('list.log')->record(array('ename' => $eventName)); $this->emit($eventName, ''); endif; } protected function processText($data) { $tplXmlArray = array( 'ToUserName' => $this->rawDataArray['FromUserName'], 'FromUserName' => $this->rawDataArray['ToUserName'], 'CreateTime' => time(), 'MsgType' => 'text', 'Content' => $data, ); arComp('list.log')->record($tplXmlArray); return urldecode(arComp('ext.out')->array2xml(arComp('format.format')->urlencode($tplXmlArray), false, 'xml')); } protected function processNews($data) { $tplXmlArray = array( 'ToUserName' => $this->rawDataArray['FromUserName'], 'FromUserName' => $this->rawDataArray['ToUserName'], 'CreateTime' => time(), 'MsgType' => 'news', 'Articles' => array(), ); if (arComp('validator.validator')->checkMutiArray($data)) : $tplXmlArray['ArticleCount'] = count($data); foreach ($data as $news) : $tplXmlArray['Articles']['item'][] = array( 'Title' => $news[0], 'Description' => $news[1], 'PicUrl' => $news[2], 'Url' => $news[3], ); endforeach; else : $news = $data; $tplXmlArray['ArticleCount'] = "1"; $tplXmlArray['Articles']['item'][] = array( 'Title' => $news[0], 'Description' => $news[1], 'PicUrl' => $news[2], 'Url' => $news[3], ); endif; arComp('list.log')->record($tplXmlArray); $str = urldecode(arComp('ext.out')->array2xml(arComp('format.format')->urlencode($tplXmlArray), false, 'xml')); return $str = preg_replace("#<\d+>|</\d+>#", '', $str); } public function processWxServerRequest() { $this->weixinFirstCheck(); $rawData = file_get_contents('php://input'); arComp('list.log')->record($rawData, 'raw'); if ($rawData) : $xmlArray = arComp('ext.out')->xml2array($rawData, true); arComp('list.log')->record(array('xml' => $xmlArray)); $this->rawDataArray = $xmlArray['xml']; else : arComp('list.log')->record('raw empty'); exit(''); endif; } public function weixinFirstCheck() { $echostr = arGet('echostr'); if ($this->checkSignature() && !empty($echostr)) : echo $echostr; arComp('list.log')->record('check first'); exit; endif; } public function registerEvent($eventName, $eventCallback) { if (empty(self::$events[$eventName])) : self::$events[$eventName] = array(); endif; array_push(self::$events[$eventName], $eventCallback); } private static function emit($eventName) { if (!empty(self::$events[$eventName])) : $args = array_slice(func_get_args(), 1); arComp('list.log')->record($args); arComp('list.log')->record(self::$events[$eventName]); if (empty($args)) : $args = array(); endif; foreach (self::$events[$eventName] as $callback) : call_user_func_array($callback, $args); endforeach; else : arComp('list.log')->record('event empty'); endif; } } 
 class ArFormat extends ArComponent { public function timeToDate($obj, $key = '', $forMat = 'm-d') { if (Ar::c('validator.validator')->checkMutiArray($obj)) : foreach ($obj as &$time) : $time = $this->timeToDate($time, $key, $forMat); endforeach; elseif (is_array($obj)) : if (isset($obj[$key])) : $obj[$key] = $this->timeToDate($obj[$key], '', $forMat); endif; else : $obj = date($forMat, Ar::c('validator.validator')->checkNumber($obj) ? $obj : strtotime($obj)); endif; return $obj; } public function replace($key, $value, $obj) { if (is_array($obj)) : foreach($obj as &$o) : $o = $this->replace($key, $value, $o); endforeach; else : $obj = str_replace($key, $value, $obj); endif; return $obj; } public function stripslashes($obj) { if (is_array($obj)) : foreach($obj as &$o) : $o = $this->stripslashes($o); endforeach; else : $obj = stripslashes($obj); endif; return $obj; } public function trim($obj) { if (is_array($obj)) : foreach($obj as &$o) : $o = $this->trim($o); endforeach; else : $obj = trim($obj); endif; return $obj; } public function encrypt($obj, $key = '') { if (is_array($obj)) : if (Ar::c('validator.validator')->checkMutiArray($obj)) : foreach ($obj as &$eObj) : $eObj = $this->encrypt($eObj, $key); endforeach; else : if (!empty($obj[$key])) : $obj[$key] = $this->encrypt($obj[$key]); endif; endif; else : $obj = Ar::c('hash.mcrypt')->encrypt($obj); endif; return $obj; } public function urldecode($obj, $key = '') { if (is_array($obj)) : if (empty($obj[$key])) : foreach ($obj as &$eObj) : $eObj = $this->urldecode($eObj, $key); endforeach; else : $obj[$key] = $this->urldecode($obj[$key]); endif; else : $obj = urldecode($obj); endif; return $obj; } public function urlencode($obj, $key = '') { if (is_array($obj)) : if (empty($obj[$key])) : foreach ($obj as &$eObj) : $eObj = $this->urlencode($eObj, $key); endforeach; else : $obj[$key] = $this->urlencode($obj[$key]); endif; else : if (!is_numeric($obj)) : $obj = urlencode($obj); endif; endif; return $obj; } public function convertCharset($obj, $key = '', $in = 'gbk', $to = 'utf-8') { if (is_array($obj)) : if (empty($obj[$key])) : foreach ($obj as &$eObj) : $eObj = $this->urlencode($eObj, $key); endforeach; else : $obj[$key] = $this->urlencode($obj[$key]); endif; else : $obj = iconv($in, $to, $obj); endif; return $obj; } public function addslashes() { $args = func_get_args(); foreach ($args as $k => &$arg) : if (is_array($arg) || is_object($arg)) : foreach ($arg as $v => &$narg) : $narg = is_scalar($narg) ? addslashes($narg) : $this->addslashes($narg); endforeach; else : $arg = addslashes($arg); endif; endforeach; if (count($args) == 1) : $args = $args[0]; endif; return $args; } public function filterKey(array $gar, array $data) { foreach ($data as $k => $v) : if (is_numeric($k) || !in_array($k, $gar)) : unset($data[$k]); endif; endforeach; return $data; } function arrayMergeRecursiveDistinct(array $arrayFirst, array $arraySecond) { $merged = $arrayFirst; foreach ($arraySecond as $key => &$value) : if (is_array($value) && isset($merged[$key]) && is_array($merged[$key])) : $merged[$key] = $this->arrayMergeRecursiveDistinct($merged[$key], $value); else : $merged[$key] = $value; endif; endforeach; return $merged; } } 
 class ArMcrypt extends ArComponent { private $_key; private $_ivSize; static public function init($config = array(), $class = __CLASS__) { $hashObject = parent::init($config, $class); $key = empty($hashObject->config['key']) ? 'ArPHP_GO_GO_GO' : $hashObject->config['key']; $key = hash('ripemd128', $key); $hashObject->_key = pack('H*', $key); $hashObject->_ivSize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC); return $hashObject; } public function setKey($key = '') { if ($key) : $this->_key = $key; endif; return true; } public function encrypt($plaintext) { $key = $this->_key; $key_size = strlen($key); $iv_size = $this->_ivSize; $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND); $ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $plaintext, MCRYPT_MODE_CBC, $iv); $ciphertext = $iv . $ciphertext; $ciphertext_base64 = base64_encode($ciphertext); return str_replace(array('/', '\\', '+'), array('z_x_g', 'f_x_g', 'j_i_a'), $ciphertext_base64); } public function decrypt($ciphertext_base64) { $key = $this->_key; $iv_size = $this->_ivSize; $ciphertext_dec = base64_decode(str_replace(array('z_x_g', 'f_x_g', 'j_i_a'), array('/', '\\', '+'), $ciphertext_base64)); $iv_dec = substr($ciphertext_dec, 0, $iv_size); $ciphertext_dec = substr($ciphertext_dec, $iv_size); $plaintext_dec = @mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec); return trim($plaintext_dec); } } 
 class ArOpenssl extends ArComponent { private $_pub_key; private $_source_pub_key; private $_prv_key; private $_source_prv_key; static public function init($config = array(), $class = __CLASS__) { $hashObject = parent::init($config, $class); if (empty($hashObject->config['pub_key'])) : throw new ArException("openssl public key invalid", 3001); endif; $hashObject->setKey($hashObject->config['pub_key']); if (isset($hashObject->config['prv_key'])) : $hashObject->setKey($hashObject->config['prv_key'], false); endif; return $hashObject; } public function setKey($key = '', $public = true) { if ($key) : if ($public) : $this->_pub_key = $key; $this->_source_pub_key = openssl_pkey_get_public($this->_pub_key); else : $this->_prv_key = $key; $this->_source_prv_key = openssl_pkey_get_private($this->_prv_key); endif; endif; return true; } public function encrypt($plaintext, $public = true) { $ciphertext = ''; if ($public) : openssl_public_encrypt($plaintext, $ciphertext, $this->_source_pub_key); else : openssl_private_encrypt($plaintext, $ciphertext, $this->_source_prv_key); endif; $ciphertext = base64_encode($ciphertext); return $ciphertext; } public function decrypt($ciphertext_base64, $public = true) { if ($public) : openssl_public_decrypt(base64_decode($ciphertext_base64), $decrypted, $this->_source_pub_key); else : openssl_private_decrypt(base64_decode($ciphertext_base64), $decrypted, $this->_source_prv_key); endif; return $decrypted; } } 
 class ArArrayList extends ArList { } 
 class ArList extends ArComponent { protected $c = array(); public function contains($key) { return isset($this->c[$key]); } public function set($key, $value) { $this->c[$key] = $value; } public function get($key) { $r = null; if ($this->contains($key)) : $r = $this->c[$key]; endif; return $r; } public function flush() { $this->c = array(); } } 
 class ArLog extends ArList { protected $logPath; static public function init($config = array(), $class = __CLASS__) { $obj = parent::init($config, $class); $obj->logPath = empty($obj->config['logPath']) ? (AR_OUTER_START ? AR_ROOT_PATH . 'Log' . DS : arCfg('PATH.LOG')) : $obj->config['logPath']; if(!is_dir($obj->logPath)) : mkdir($obj->logPath, 0777, true); endif; return $obj; } public function record($data = '', $level = 'info') { if (is_array($data)) : $data = var_export($data, true); endif; $data = '------' . date('Y-m-d H:i:s', time()) . ' ' . time() . "------\n" . $data . "\n"; return file_put_contents($this->generateLogFileName($level), $data, FILE_APPEND); } protected function generateLogFileName($level) { $dirName = $this->logPath . date('Ymd') . DS; if(!is_dir($dirName)) : mkdir($dirName, 0777, true); endif; return $dirName . $level . '.log.txt'; } } 
 class ArSession extends ArList { static public function init($config = array(), $class = __CLASS__) { $obj = parent::init($config, $class); $obj->setContainer($_SESSION); return $obj; } public function setContainer(&$value) { $this->c = &$value; } }
 class ArApi extends ArComponent { public $method = 'get'; public $curlOptions = array(); public function handleCookie($file = '') { if (!$file) : $file = AR_ROOT_PATH . 'cookiefile'; endif; if (!file_exists($file)) : file_put_contents($file, ''); endif; $this->curlOptions[CURLOPT_COOKIEJAR] = $file; $this->curlOptions[CURLOPT_COOKIEFILE] = $file; } public function remoteCall($url, $params = array(), $method = '') { if ($method) : $this->method = $method; else : $this->method = empty($this->config['method']) ? 'get' : $this->config['method']; endif; $options = array(CURLOPT_HEADER => false, CURLOPT_RETURNTRANSFER => 1); if ($this->method == 'post') : $options[CURLOPT_POST] = true; $options[CURLOPT_POSTFIELDS] = $params; else : if (is_array($params)) : $queryString = http_build_query($params); if (strpos($url, '?') === false) : $url .= '?' . $queryString; else : $url .= '&' . $queryString; endif; endif; endif; $init = curl_init($url); if ($this->curlOptions) : foreach ($this->curlOptions as $ckey => $opt) : $options[$ckey] = $opt; endforeach; endif; curl_setopt_array($init, $options); $rtStr = curl_exec($init); if ($rtStr === false) : throw new ArException('Curl error: ' . curl_error($init)); endif; if ($curlInfo = curl_getinfo($init)) : switch ($curlInfo['http_code']) { case '404': throw new ArException('Curl error: ' . 'url ' . '"' . $curlInfo['url'] . '" not found'); break; default: break; } endif; curl_close($init); return $rtStr; } public function callApi($api) { } protected function parse($parseStr) { } public function encrypt($data) { return arComp('hash.mcrypt')->encrypt(serialize($data)); } public function decrypt($data) { return unserialize(arComp('hash.mcrypt')->decrypt($data)); } } 
 class ArProxy extends ArApi { static $MIMETYPEMAP = array( 'image/gif' => 'gif', 'image/jpeg' => 'jpg', 'image/pjpeg' => 'jpg', 'image/png' => 'png', 'image/tiff' => 'tif', ); protected $domainInfo = array(); protected $mimeType = 'text/html'; protected $fileSuffix; public function remoteCall($url, $params = array(), $method = '') { if ($method) : $this->method = $method; else : $this->method = empty($this->config['method']) ? 'get' : $this->config['method']; endif; $this->parse($url); $init = curl_init($url); $options = array( CURLOPT_RETURNTRANSFER => 1, CURLOPT_AUTOREFERER => 1, CURLOPT_RETURNTRANSFER => 1, CURLOPT_HTTPHEADER => array( 'User-Agent' => 'User-Agent:Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36', 'Host' => $this->domainInfo['host'], 'Referer' => $this->domainInfo['referer'], ) ); if ($this->method == 'post') : $options[CURLOPT_POST] = true; $options[CURLOPT_POSTFIELDS] = $params; endif; curl_setopt_array($init, $options); $rtStr = curl_exec($init); $info = curl_getinfo($init); if (!empty($info['content_type'])) : $this->mimeType = $info['content_type']; if (array_key_exists($this->mimeType, self::$MIMETYPEMAP)) : $this->fileSuffix = self::$MIMETYPEMAP[$this->mimeType]; endif; endif; curl_close($init); return $rtStr; } public function callApi($url, $show = true) { $source = $this->remoteCall($url); if ($show === true) : header('Content-Type:' . $this->mimeType); echo $source; else : if (strstr($show, '.') === false && $this->fileSuffix) : $show .= '.' . $this->fileSuffix; endif; file_put_contents($show, $source); return $show; endif; } protected function parse($url) { $uInfo = parse_url($url); if (empty($uInfo['host']) || empty($uInfo['scheme'])) : throw new ArException('url ' . $url . ' may have a valid host'); endif; $this->domainInfo['host'] = $uInfo['host']; $this->domainInfo['referer'] = $uInfo['scheme'] . '://'. $uInfo['host']; } } 
 class ArService extends ArApi { protected $TAG_MSG_SEP = '___SERVICE_STD_OUT_SEP___'; protected $remoteWsFile = ''; static public function init($config = array(), $class = __CLASS__) { $obj = parent::init($config, $class); $obj->setRemoteWsFile(); return $obj; } public function setRemoteWsFile($wsFile = '') { if (empty($wsFile)) : $this->remoteWsFile = empty($this->config['wsFile']) ? arComp('url.route')->host() . '/arws.php' : $this->config['wsFile']; else : $this->remoteWsFile = $wsFile; endif; } public function setAuthUserSignature($sign = array()) { $this->remoteQueryUrlSign = $sign; } public function gRemoteWsUrl() { return $this->remoteWsFile . '?' . http_build_query($this->remoteQueryUrlSign); } public function __call($name, $args = array()) { $remoteQueryUrlSign = array(); $remoteQueryData = array(); if (substr($name, 0, 2) === 'Ws') : $remoteQueryData['class'] = ltrim($name, 'Ws'); $remoteQueryData['method'] = $args[0]; $remoteQueryData['param'] = empty($args[1]) ? array() : $args[1]; else : throw new ArException("Service do not have a method " . $name); endif; $this->setAuthUserSignature($remoteQueryUrlSign); $postServiceData = array('ws' => $this->encrypt($remoteQueryData)); return $this->callApi($this->gRemoteWsUrl(), $postServiceData); } public function callApi($url, $args = array()) { $response = $this->remoteCall($url, $args, 'post'); return $this->processResponse($response); } public function response($data = '') { echo $this->TAG_MSG_SEP . $this->encrypt($data); exit; } protected function processResponse($response = '') { if (empty($response)) : throw new ArException('Remote Service Error (  Service Response Empty )', '1012'); endif; if (preg_match('#.*error.*on line.*#', $response)) : throw new ArException('Remote Service Error ( ' . $response . ' )', '1101'); endif; if (($pos = strpos($response, $this->TAG_MSG_SEP)) !== false) : if ($pos === 0) : $response = substr($response, strlen($this->TAG_MSG_SEP)); else : list($stdOutMsg, $response) = explode($this->TAG_MSG_SEP, $response); if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->debug('[SERVICE_STD_OUT_MSG]'); arComp('ext.out')->debug($stdOutMsg); endif; endif; else : throw new ArException('not found response hanlder ', '1011'); endif; $remoteBackResult = $this->decrypt($response); if (is_array($remoteBackResult) && !empty($remoteBackResult['error_msg'])) : throw new ArException($remoteBackResult['error_msg'], $remoteBackResult['error_code']); endif; return $remoteBackResult; } } 
 class ArSource extends ArApi { protected function parse($parseStr) { return $parseStr; } protected function getApi($api, $params) { if (strpos($api, 'http://') === false) : if (arCfg('URL_MODE') == 'PATH') : $prefix = rtrim(empty($this->config['remotePrefix']) ? arComp('url.route')->ServerName() : $this->config['remotePrefix'], '/'); endif; else : $prefix = ''; endif; if (!empty($params['curlOptions'])) : $this->curlOptions = $params['curlOptions']; unset($params['curlOptions']); endif; switch ($this->method) { case 'get' : if (empty($this->config['remotePrefix'])) : $prefix .= arU($api, $params); else : $prefix .= '/' . ltrim($api, '/'); if (!empty($params)) : $prefix .= '?' . http_build_query($params); endif; endif; break; case 'post' : $prefix .= empty($this->config['remotePrefix']) ? arU($api) : ('/' . ltrim($api, '/')); break; } $url = trim($prefix, '/'); return $this->remoteCall($url, $params, $this->method); } public function callApi($api, $params = array(), $method = '') { if ($method) : $this->method = $method; else : $this->method = empty($this->config['method']) ? 'get' : $this->config['method']; endif; $result = $this->getApi($api, $params); return $this->parse($result); } } 
 class ArJson extends ArSource { protected function parse($parseStr) { return $this->parseJson($parseStr); } protected function parseJson($parseStr) { return json_decode($parseStr, 1); } } 
 class ArUtil extends ArComponent { public function getClientIp() { $unknown = 'unknown'; if (isset($_SERVER['HTTP_X_FORWARDED_FOR']) && $_SERVER['HTTP_X_FORWARDED_FOR'] && strcasecmp($_SERVER['HTTP_X_FORWARDED_FOR'], $unknown)) : $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; elseif (isset($_SERVER['REMOTE_ADDR']) && $_SERVER['REMOTE_ADDR'] && strcasecmp($_SERVER['REMOTE_ADDR'], $unknown)) : $ip = $_SERVER['REMOTE_ADDR']; endif; if (false !== strpos($ip, ',')) $ip = reset(explode(',', $ip)); return $ip; } public function getServerIp($os = 'linux', $cli = true) { if ($os == 'linux' && $cli == true) : $ss = @exec('/sbin/ifconfig eth0 | sed -n \'s/^ *.*addr:\\([0-9.]\\{7,\\}\\) .*$/\\1/p\'',$arr); $server_ip = $arr[0]; else : if (isset($_SERVER)) : if ($_SERVER['SERVER_ADDR']) : $server_ip = $_SERVER['SERVER_ADDR']; else : $server_ip = $_SERVER['LOCAL_ADDR']; endif; else : $server_ip = getenv('SERVER_ADDR'); endif; endif; return $server_ip; } public function substr_cut($str, $len, $charset="utf-8"){ if (!is_numeric($len) or $len <= 0) : return ''; endif; $sLen = strlen($str); if ($len >= $sLen) : return $str; endif; if (strtolower($charset) == "utf-8") : $len_step = 3; else : $len_step = 2; endif; $len_i = 0; $substr_len = 0; for($i=0; $i < $sLen; $i++) : if ($len_i >= $len) break; if(ord(substr($str,$i,1)) > 0xa0) : $i += $len_step - 1; $substr_len += $len_step; else : $substr_len++; endif; $len_i++; endfor; $result_str = substr($str, 0, $substr_len); return $result_str; } public function randpw($len = 8, $format = 'ALL') { $is_abc = $is_numer = 0; $password = $tmp =''; switch ($format) { case 'ALL': $chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; break; case 'CHAR': $chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'; break; case 'NUMBER': $chars='0123456789'; break; default : $chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; break; } while (strlen($password) < $len) : $tmp =substr($chars, (mt_rand()%strlen($chars)), 1); if (($is_numer <> 1 && is_numeric($tmp) && $tmp > 0 )|| $format == 'CHAR') : $is_numer = 1; endif; if (($is_abc <> 1 && preg_match('/[a-zA-Z]/', $tmp)) || $format == 'NUMBER') : $is_abc = 1; endif; $password .= $tmp; endwhile; if ($is_numer <> 1 || $is_abc <> 1 || empty($password)) : $password = $this->randpw($len, $format); endif; return $password; } } 
 class ArRoute extends ArComponent { public function serverPath($dir, $showServerName = false) { $dir = str_replace(DS, '/', $dir); $path = dirname($_SERVER['SCRIPT_FILENAME']); $position = strpos($dir, $path); if ($position !== false) : $dir = AR_SERVER_PATH . trim(str_replace($path, '', $dir), '/'); endif; return ($showServerName ? $this->serverName() : '') . $dir; } public function pathToDir($path) { if (strpos($path, '/') === 0) : $dir = rtrim(realpath($_SERVER['DOCUMENT_ROOT']), DS) . DS; $path = trim($path, '/'); $path = str_replace('/', DS, $path); $dir = $dir . $path; else : $path = str_replace('/', DS, $path); $dir = AR_ROOT_PATH . $path; endif; return $dir; } public function host($scriptName = false) { $host = $this->serverName() . '/' . trim(str_replace(array('/', '\\', DS), '/', dirname($_SERVER['SCRIPT_NAME'])), '/'); $host = rtrim($host, '/'); if ($scriptName) : $host .= '/' . basename($_SERVER['SCRIPT_NAME']); endif; return $host; } public function serverName() { return 'http://' . $_SERVER['HTTP_HOST']; } public function parseUrlForRules($url) { $phpSelf = $_SERVER['SCRIPT_NAME']; if (strpos($url, $phpSelf) !== false) : $url = str_replace($phpSelf, '', $url); endif; $foundMode = false; $baseTrimUrl = substr($url, strlen(AR_SERVER_PATH)); $absolutePath = ltrim($baseTrimUrl, '/'); if (strpos($absolutePath, '?') !== false) : $absolutePath = substr($absolutePath, 0, strpos($absolutePath, '?')); endif; if (strpos($absolutePath, '/') === false) : $virtualModule = $absolutePath; else : $virtualModule = substr($absolutePath, 0, strpos($absolutePath, '/')); endif; if (!in_array($virtualModule, arCfg('moduleLists'))) : if (arCfg('URL_MODE') == 'FULL') : $virtualModule = arRequest('a_m'); else : $virtualModule = AR_DEFAULT_APP_NAME; endif; endif; $appConfigFile = AR_ROOT_PATH . $virtualModule . DS . 'Conf' . DS . 'app.config.php'; $iniConfigFile = AR_ROOT_PATH . $virtualModule . DS . 'Conf' . DS . 'app.config.ini'; $appConfig = Ar::import($appConfigFile, true); $iniConfig = Ar::import($iniConfigFile, true); if (!empty($iniConfig)) : Ar::setConfig('', arComp('format.format')->arrayMergeRecursiveDistinct(Ar::getConfig(), $iniConfig)); endif; if (!empty($appConfig)) : Ar::setConfig('', arComp('format.format')->arrayMergeRecursiveDistinct(Ar::getConfig(), $appConfig)); endif; $urlRouteRules = arCfg('URL_ROUTE_RULES'); if (is_array($urlRouteRules)) : foreach ($urlRouteRules as $key => $rules) : if (is_array($rules['mode'])) : foreach ($rules['mode'] as $mode) : if ($mode === $absolutePath) : $url = AR_SERVER_PATH . $key; $foundMode = true; break 2; endif; preg_match_all('|:(.*):|U', $mode, $match); if (!empty($match[1])) : $mode = preg_replace('|(:.*:)|U', '([a-zA-z0-9%]+)', $mode); $urlRegRules = '|' . $mode . '|'; if (preg_match_all($urlRegRules, $url, $matchRules)) : $lengthOfVariable = count($match[1]); for ($i = 0; $i < $lengthOfVariable; $i++) : $rulesKey = $i + 1; $_GET[$match[1][$i]] = $matchRules[$rulesKey][0]; endfor; $url = preg_replace('|(.*)' . $mode . '(.*)|', "$1" . $key . "$" . ($lengthOfVariable + 2), $url); break; else : continue; endif; endif; endforeach; else : throw new ArException('URL_ROUTE_RULES : "' . $key . '" mode should be an Array', 1006); endif; endforeach; endif; return $url; } public function parse() { $requestUrl = $this->parseUrlForRules($_SERVER['REQUEST_URI']); $phpSelf = $_SERVER['SCRIPT_NAME']; if (($pos = strpos($requestUrl, '?')) !== false) : $queryStr = substr($requestUrl, $pos + 1); $requestUrl = substr($requestUrl, 0, $pos); endif; if (($root = dirname($phpSelf)) != '/' && $root != '\\') : $requestUrl = preg_replace("#^{$root}#", '', $requestUrl); endif; $requestUrl = trim($requestUrl, '/'); if (arCfg('URL_MODE', 'PATH') == 'PATH' && arCfg('URL_SUFFIX')) : if (($posSuffix = strrpos($requestUrl, '.' . arCfg('URL_SUFFIX'))) !== false) : $requestUrl = substr($requestUrl, 0, $posSuffix); endif; endif; $pathArr = explode('/', $requestUrl); $temp = array_shift($pathArr); $m = in_array($temp, Ar::getConfig('moduleLists', array())) ? $temp : AR_DEFAULT_APP_NAME; $c = in_array($temp, Ar::getConfig('moduleLists', array())) ? array_shift($pathArr) : $temp; $a = array_shift($pathArr); while ($gkey = array_shift($pathArr)) : $_GET[$gkey] = array_shift($pathArr); endwhile; if (!empty($queryStr)) : parse_str($queryStr, $query); foreach ($_GET as $gkey => $gval) : if (array_key_exists($gkey, $query) && empty($query[$gkey])) : unset($query[$gkey]); endif; endforeach; $_GET = array_merge($_GET, $query); endif; if (arGet('a_m')) : $m = arGet('a_m'); endif; if (arGet('a_c')) : $c = arGet('a_c'); endif; if (arGet('a_a')) : $a = arGet('a_a'); endif; $a_h = ''; if (strpos($_SERVER['HTTP_HOST'], '.') !== false) : $serverHostArray = explode('.', $_SERVER['HTTP_HOST']); if (count($serverHostArray) == 3) : $a_h = $serverHostArray[0]; endif; endif; $moduleLists = arCfg('moduleLists'); if (empty($c) && empty($a)) : if ($a_h && is_array($moduleLists) && in_array($a_h, $moduleLists)) : $m = $a_h; endif; endif; $requestRoute = array('a_h' => $a_h, 'a_m' => $m, 'a_c' => empty($c) ? AR_DEFAULT_CONTROLLER : $c, 'a_a' => empty($a) ? AR_DEFAULT_ACTION : $a); Ar::setConfig('requestRoute', $requestRoute); return $requestRoute; } public function parseGetUrlIntoArray() { static $staticMark = array( 'firstParse' => true, 'getUrlParamArray' => array(), ); if ($staticMark['firstParse']) : $parseUrl = parse_url($_SERVER['REQUEST_URI']); if (empty($parseUrl['query'])) : else : parse_str($parseUrl['query'], $query); foreach ($_GET as $gkey => $gval) : if (array_key_exists($gkey, $query) && empty($query[$gkey])) : unset($query[$gkey]); endif; endforeach; $staticMark['getUrlParamArray'] = $query; endif; $staticMark['getUrlParamArray'] = array_merge($_GET, $staticMark['getUrlParamArray']); $staticMark['firstParse'] = false; endif; return $staticMark['getUrlParamArray']; } public function createUrl($urlKey = '', $params = array(), $urlMode = 'NOT_INIT') { $url = $urlKey; $urlRouteRules = arCfg('URL_ROUTE_RULES'); $defaultModule = arCfg('requestRoute.a_m') == AR_DEFAULT_APP_NAME ? '' : arCfg('requestRoute.a_m'); if ($urlMode === 'NOT_INIT') : $urlMode = arCfg('URL_MODE', 'PATH'); endif; $prefix = rtrim(AR_SERVER_PATH . $defaultModule, '/'); $urlParam = arCfg('requestRoute'); $urlParam['a_m'] = $defaultModule; if (isset($params['greedyUrl']) && $params['greedyUrl'] === false) : else : if ((isset($params['greedyUrl']) && $params['greedyUrl'] === true) || arCfg('URL_GREEDY') === true) : unset($params['greedyUrl']); unset($_GET['a_m']); unset($_GET['a_c']); unset($_GET['a_a']); if (is_array(arGet())) : $getArr = arGet(); unset($getArr['a_m']); unset($getArr['a_c']); unset($getArr['a_a']); $params = array_merge($getArr, $params); endif; endif; endif; if (isset($params['ar_back']) && $params['ar_back'] === true) : unset($params['ar_back']); arComp('list.session')->set('ar_back_url', $_SERVER['REQUEST_URI']); endif; if (empty($url)) : if ($urlMode == 'PATH') : $controller = arCfg('requestRoute.a_c'); $action = arCfg('requestRoute.a_a'); $url .= '/' . $controller . '/' . $action; $urlKey = trim($url, '/'); $url = $prefix . $url; endif; else : if (strpos($url, 'http') === 0) : $urlArr = parse_url($url); $reBuildUrlArr = $params; if (!empty($urlArr['query'])) : parse_str($urlArr['query'], $urlStrArr); $reBuildUrlArr = array_filter(array_merge($params, $urlStrArr)); $baseUrl = substr($url, 0, strpos($url, '?')); else : $baseUrl = rtrim($url, '?'); endif; $reBuildUrl = $baseUrl . '?' . http_build_query($reBuildUrlArr); return $reBuildUrl; elseif (strpos($url, '/') === false) : if ($urlMode != 'PATH') : $urlParam['a_a'] = $url; else : $url = $prefix . '/' . arCfg('requestRoute.a_c') . '/' . $url; endif; elseif (strpos($url, '/') === 0) : if ($urlMode != 'PATH') : $eP = explode('/', ltrim($url, '/')); $urlParam['a_m'] = $eP[0]; $urlParam['a_c'] = isset($eP[1]) ? $eP[1] : null; $urlParam['a_a'] = isset($eP[2]) ? $eP[2] : null; else : $url = ltrim($url, '/'); $url = AR_SERVER_PATH . $url; endif; else : if ($urlMode != 'PATH') : $eP = explode('/', $url); $urlParam['a_c'] = $eP[0]; $urlParam['a_a'] = $eP[1]; else : $url = $prefix . '/' . $url; endif; endif; endif; if ($urlMode != 'PATH') : $urlParam = array_filter(array_merge($urlParam, $params)); endif; if (empty($urlMode)) : $urlMode = 'PATH'; endif; switch ($urlMode) { case 'PATH' : if (strpos($urlKey, '/') === false) : $urlKey = arCfg('requestRoute.a_c') . '/' . $urlKey; endif; if (array_key_exists($urlKey, $urlRouteRules)) : $findMode = false; if (is_array($urlRouteRules[$urlKey]['mode'])) : foreach ($urlRouteRules[$urlKey]['mode'] as $mode) : if ($findMode) : break; endif; if (!preg_match('|:(.*):|', $mode)) : $url = str_replace($urlKey, $mode, $url); $findMode = true; break; else : $tempUrl = str_replace($urlKey, $mode, $url); preg_match_all('|:(.*):|U', $tempUrl, $match); if (!empty($match[1])) : $sizeMatch = count($match[1]); for ($i = 0; $i < $sizeMatch; $i++) : $variable = $match[1][$i]; if (array_key_exists($variable, $params)) : $tempUrl = str_replace(':' . $variable . ':', $params[$variable], $tempUrl); if ($i == ($sizeMatch - 1)) : $findMode = true; $url = $tempUrl; foreach ($match[1] as $variable) : unset($params[$variable]); endforeach; break; endif; else : break; endif; endfor; endif; endif; endforeach; else : throw new ArException('URL_ROUTE_RULES : "' . $urlKey . '" mode should be an Array', 1006); endif; endif; foreach ($params as $pkey => $pvalue) : if (!$pvalue && !is_numeric($pvalue)) : continue; endif; $url .= '/' . $pkey . '/' . $pvalue; endforeach; if (arCfg('URL_SUFFIX')) : $url = $url . '.' . arCfg('URL_SUFFIX'); endif; break; case 'QUERY' : $url = arComp('url.route')->host() . '?' . http_build_query($urlParam); break; case 'FULL' : $url = arComp('url.route')->host(true) . '?' . http_build_query($urlParam); break; } return $url; } public function redirect($r = '', $show = '', $time = '0', $seg = '') { $show = trim($show); $show = preg_replace("/\n/", ' ', $show); if (is_string($r)) : $url = ''; if (empty($r)) : $urlTemp = arComp('list.session')->get('ar_back_url'); if ($urlTemp) : $url = $urlTemp; arComp('list.session')->set('ar_back_url', null); endif; else : if ($r == 'ar_up') : if (!empty($_SERVER['HTTP_REFERER'])) : $url = $_SERVER['HTTP_REFERER']; endif; elseif (strpos($r, 'http') !== false) : $url = $r; else : $url = arU($r); endif; endif; else : $route = empty($r[0]) ? '' : $r[0]; $param = empty($r[1]) ? array() : $r[1]; $url = arComp('url.route')->createUrl($route, $param); endif; $redirectUrl = <<<str
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Refresh" content="$time;URL=$url" />
</head>
<body>
$show<a href="$url">立即跳转</a>
</body>
</html>
str;
if ($seg) : $seg = 'Redirect/' . $seg; try { arSeg(array('segKey' => $seg, 'url' => $url, 'show' => $show, 'time' => $time)); exit; } catch (ArException $e) { } endif; echo $redirectUrl; exit; } } 
 class ArSkeleton extends ArComponent { public $appName = ''; protected $basePath = ''; public function generateFolders() { $folderLists = array( $this->basePath, AR_PUBLIC_CONFIG_PATH, $this->basePath . 'Controller', $this->basePath . 'View', $this->basePath . 'View' . DS . 'Index', $this->basePath . 'Ext', $this->basePath . 'Model', $this->basePath . 'Conf', $this->basePath . 'Public', ); foreach($folderLists as $folder) : if (!$this->check($folder)) : if (!@mkdir($folder)) : throw new ArException("folder $folder create failed !"); endif; endif; endforeach; } public function generateFiles() { $fileLists = array( $this->basePath . 'Controller' . DS . 'IndexController.class.php' => '<?php
/**
 * Powerd by ArPHP.
 *
 * Controller.
 *
 * @author ycassnr <ycassnr@gmail.com>
 */

/**
 * Default Controller of webapp.
 */
class IndexController extends ArController
{
    /**
     * just the example of get contents.
     *
     * @return void
     */
    public function indexAction()
    {
        $this->display();

    }

}', $this->basePath . 'Model' . DS . 'MyModel.class.php' => '<?php
/**
 * Powerd by ArPHP.
 *
 * Model.
 *
 * @author ycassnr <ycassnr@gmail.com>
 */

/**
 * Default Model of webapp.
 */
class MyModel extends ArModel
{

    static public function model($class = __CLASS__)
    {
        return parent::model($class);

    }

    public function yourFunction()
    {
        echo "this is your funciton";

    }

}', $this->basePath . 'View' . DS . 'Index' . DS . 'index.php' => '<html>
    <h1>Hello, ArPHP ! </h1>
    this is your view file !
</html>
', $this->basePath . 'Conf' . DS . 'app.config.php' => '<?php
/**
 * Ar default app config file.
 *
 * @author ycassnr <ycassnr@gmail.com>
 */
return array(
);', AR_PUBLIC_CONFIG_PATH . 'public.config.php' => '<?php
/**
 * Ar default public config file.
 *
 * @author ycassnr <ycassnr@gmail.com>
 */
return array(
    \'moduleLists\' => array(
        \'' . $this->appName . '\'
    ),
);', ); foreach($fileLists as $file => $content) : if (!$this->check($file)) : file_put_contents($file, $content); endif; endforeach; } public function check($file) { return is_file($file) || is_dir($file); } public function generate($appName = '') { if (empty($appName) && $appGlobalConfig = Ar::import(AR_PUBLIC_CONFIG_PATH . 'public.config.php', true)) : if (empty($appGlobalConfig['moduleLists'])) : if (!AR_DEFAULT_APP_NAME) : return; else : throw new ArException("can not find param 'moduleLists'!"); endif; endif; $moduleLists = $appGlobalConfig['moduleLists']; foreach ($moduleLists as $moduleName) : $this->generate($moduleName); endforeach; endif; $this->appName = $appName ? $appName : AR_DEFAULT_APP_NAME; $this->basePath = AR_ROOT_PATH . $this->appName . DS; if (!$this->check($this->basePath)) : $this->generateFolders(); $this->generateFiles(); endif; } public function generateCmdFile() { $folderMan = AR_CMD_PATH; $folderConf = $folderMan . 'Conf' . DS; $folderBin = $folderMan . 'Bin' . DS; $configFile = $folderConf . 'app.config.ini'; if (!$this->check($folderMan)) : mkdir($folderMan); endif; if (!$this->check($folderConf)) : mkdir($folderConf); endif; if (!$this->check($folderBin)) : mkdir($folderBin); endif; if (!$this->check($configFile)) : file_put_contents($configFile, ';cmd config file
listen_port=10008
listen_ip=127.0.0.1'); endif; } public function generateIntoOther() { $folderMan = AR_MAN_PATH; $folderConf = $folderMan . 'Conf' . DS; $configFile = $folderConf . 'public.config.php'; if (!$this->check($folderMan)) : mkdir($folderMan); endif; if (!$this->check($folderConf)) : mkdir($folderConf); endif; if (!$this->check($configFile)) : file_put_contents($configFile, '<?php
/**
 * Ar default public config file.
 *
 * @author ycassnr <ycassnr@gmail.com>
 */
return array(
    );'); endif; } } 
 class ArValidator extends ArComponent { public function checkNumber($obj) { return is_numeric($obj); } public function checkMutiArray($obj) { $rt = true; if (is_array($obj)) : foreach ($obj as $arr) : if (!is_array($arr)) : $rt = false; break; endif; endforeach; else : $rt = false; endif; return $rt; } public function checkUrl($url) { return preg_match("#^(http)#", $url); } public function checkArrayKeyEqual(array $arri, array $arro) { $lengthi = count($arri); $lengtho = count($arro); $rt = true; if ($lengthi !== $lengtho) : $rt = false; else : foreach ($arri as $ikey => $ivalue) : if (!array_key_exists($ikey, $arro)) : $rt = false; break; endif; endforeach; endif; return $rt; } public function checkAjax() { if (!empty($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest') : return true; else : return false; endif; } public function checkEmpty($obj) { return empty($obj); } public function checkDataByRules(array $data, array $rules) { foreach ($rules as $k => $rule) : if (array_key_exists($k, $data)) : switch ($rule[0]) { case 'number' : if ($this->checkNumber($data[$k])) : unset($rules[$k]); endif; break; case 'required' : if (!$this->checkEmpty($data[$k])) : unset($rules[$k]); endif; break; default : if (!$this->checkEmpty($data[$k])) : unset($rules[$k]); endif; break; } endif; endforeach; return $rules; } } 
 function arComp($name = '') { return Ar::c($name); } function arCfg($name = '', $default = 'NOT_RGI') { if ($default === 'NOT_RGI') : return Ar::getConfig($name); else : return Ar::getConfig($name, $default); endif; } function arU($name = '', $params = array(), $urlMode = 'NOT_INIT') { return arComp('url.route')->createUrl($name, $params, $urlMode); } function arModule($name = '') { static $moduleList = array(); $module = $name . 'Module'; if (!array_key_exists($module, $moduleList)) : arComp('ext.out')->deBug('|MODULE_INIT:' . $module .'|'); $moduleList[$module] = new $module; if (is_callable(array($moduleList[$module], 'initModule'))) : call_user_func_array(array($moduleList[$module], 'initModule'), array()); endif; endif; if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('|MODULE_EXEC:' . $module .'|'); endif; return $moduleList[$module]; } function arGet($key = '', $default = null) { $getUrlParamsArray = arComp('url.route')->parseGetUrlIntoArray(); $ret = array(); if (empty($key)) : $ret = $getUrlParamsArray; else : if (!isset($getUrlParamsArray[$key])) : $ret = null; else : $ret = $getUrlParamsArray[$key]; endif; endif; $ret = arComp('format.format')->addslashes($ret); if (is_numeric($ret) && $ret < 2147483647 && strlen($ret) == 1) : $ret = (int)$ret; elseif (empty($ret)) : $ret = $default; endif; return arComp('format.format')->trim($ret); } function arPost($key = '', $default = null) { $ret = array(); if (empty($key)) : $ret = $_POST; else : if (!isset($_POST[$key])) : $ret = $default; else : $ret = $_POST[$key]; endif; endif; return arComp('format.format')->addslashes(arComp('format.format')->trim($ret)); } function arRequest($key = '', $default = null, $addArray = array()) { static $request = array(); if (empty($request) || !empty($addArray)) : if (!is_array($addArray)) : $addArray = array(); endif; $getArr = arGet('', array()); $postArr = arPost('', array()); $request = array_merge($getArr, $postArr, $addArray); $request = arComp('format.format')->addslashes(arComp('format.format')->trim($request)); endif; if ($key) : if (array_key_exists($key, $request)) : $ret = $request[$key]; else : $ret = $default; endif; else : $ret = $request; endif; return $ret; } function arLm($module) { return Ar::importPath(AR_ROOT_PATH . str_replace('.', DS, $module)); } function arEcho($echo = '', $default = '', $key = '', $ifecho = true) { if (is_array($default)) : $index = (int)$echo; if (arComp('validator.validator')->checkMutiArray($default)) : $echo = !empty($default[$index]) && !empty($default[$index][$key]) ? $default[$index][$key] : ''; else : $echo = empty($default[$index]) ? '' : $default[$index]; endif; else : if (empty($echo)) : $echo = $default; endif; endif; if ($ifecho) : echo $echo; else : return $echo; endif; } function arSeg($segment) { if (!is_array($segment)) : throw new ArException("segment must be an array"); endif; if (empty($segment['segKey'])) : $keyBundle = array_keys($segment); $segKey = $keyBundle[0]; else : $segKey = $segment['segKey']; endif; extract($segment); $segFile = arCfg('DIR.SEG') . str_replace('/', DS, $segKey) . '.seg'; if (!is_file($segFile)) : $segFile .= '.php'; if (!is_file($segFile)) : throw new ArException("segment file " . $segFile . ' not found'); endif; endif; include $segFile; } 
 class Ar { static private $_a = array(); static private $_c = array(); static private $_config = array(); static public $autoLoadPath; static public function init() { if (!AR_DEBUG) : error_reporting(0); endif;  self::$autoLoadPath = array( AR_CORE_PATH, AR_FRAME_PATH, AR_COMP_PATH, AR_COMP_PATH . 'Db' . DS, AR_COMP_PATH . 'Url' . DS, AR_COMP_PATH . 'Format' . DS, AR_COMP_PATH . 'Validator' . DS, AR_COMP_PATH . 'Hash' . DS, AR_COMP_PATH . 'Rpc' . DS, AR_COMP_PATH . 'List' . DS, AR_COMP_PATH . 'Cache' . DS, AR_COMP_PATH . 'Tools' . DS, AR_COMP_PATH . 'Ext' . DS ); if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('[START]'); endif; defined('AR_PUBLIC_CONFIG_PATH') or define('AR_PUBLIC_CONFIG_PATH', AR_ROOT_PATH . 'Conf' . DS); if (AR_OUTER_START) : Ar::c('url.skeleton')->generateIntoOther(); $comonConfigFile = realpath(dirname(AR_MAN_PATH)) . DS . 'Conf' . DS . 'public.config.php'; self::$_config = arComp('format.format')->arrayMergeRecursiveDistinct( Ar::import($comonConfigFile, true), Ar::import(AR_MAN_PATH . 'Conf' . DS . 'public.config.php') ); elseif (AR_AS_WEB) : Ar::c('url.skeleton')->generate(); if (!is_file(AR_PUBLIC_CONFIG_PATH . 'public.config.php') && !is_file(AR_PUBLIC_CONFIG_PATH . 'public.config.ini')) : echo 'config file not found : ' . AR_PUBLIC_CONFIG_PATH . 'public.config.php or ' . AR_PUBLIC_CONFIG_PATH . 'public.config.ini'; exit; endif; self::setConfig('', Ar::import(AR_PUBLIC_CONFIG_PATH . 'public.config.php', true)); $iniConfigFile = AR_PUBLIC_CONFIG_PATH . 'public.config.ini'; $iniConfig = Ar::import($iniConfigFile, true); if (!empty($iniConfig)) : Ar::setConfig('', arComp('format.format')->arrayMergeRecursiveDistinct(Ar::getConfig(), $iniConfig)); endif; if (AR_PUBLIC_CONFIG_FILE && is_file(AR_PUBLIC_CONFIG_FILE)) : $otherConfig = include_once AR_PUBLIC_CONFIG_FILE; if (is_array($otherConfig)) : Ar::setConfig('', arComp('format.format')->arrayMergeRecursiveDistinct($otherConfig, Ar::getConfig())); endif; endif; Ar::c('url.route')->parse(); defined('AR_APP_PATH') or define('AR_APP_PATH', AR_ROOT_PATH . (arCfg('requestRoute.a_m') ? arCfg('requestRoute.a_m') . DS : (AR_DEFAULT_APP_NAME ? AR_DEFAULT_APP_NAME . DS : ''))); defined('AR_APP_CONFIG_PATH') or define('AR_APP_CONFIG_PATH', AR_APP_PATH . 'Conf' . DS); defined('AR_APP_VIEW_PATH') or define('AR_APP_VIEW_PATH', AR_APP_PATH . 'View' . DS); defined('AR_APP_CONTROLLER_PATH') or define('AR_APP_CONTROLLER_PATH', AR_APP_PATH . 'Controller' . DS); elseif (AR_AS_CMD) : Ar::c('url.skeleton')->generateCmdFile(); self::$_config = Ar::import(AR_CMD_PATH . 'Conf' . DS . 'app.config.ini'); self::$_config = arComp('format.format')->arrayMergeRecursiveDistinct( Ar::import(AR_CMD_PATH . 'Conf' . DS . 'app.config.ini'), Ar::import(AR_CMD_PATH . 'Conf' . DS . 'app.config.php', true) ); endif; self::$_config = arComp('format.format')->arrayMergeRecursiveDistinct( 
  array( 'PATH' => array( 'APP_SERVER_PATH' => AR_SERVER_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . '/')), 'PUBLIC' => AR_SERVER_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . '/')) . 'Public/', 'GPUBLIC' => AR_SERVER_PATH . 'Public/', 'CACHE' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Cache' . DS, 'LOG' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Log' . DS, 'VIEW' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'View' . DS, 'UPLOAD' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Upload' . DS, 'EXT' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Ext' . DS, ), 'DIR' => array( 'CACHE' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Cache' . DS, 'LOG' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Log' . DS, 'VIEW' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'View' . DS, 'UPLOAD' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Upload' . DS, 'EXT' => AR_ROOT_PATH . (!arCfg('requestRoute.a_m', AR_MAN_NAME) ? '' : (arCfg('requestRoute.a_m', AR_MAN_NAME) . DS)) . 'Ext' . DS, 'SEG' => AR_PUBLIC_CONFIG_PATH . 'Seg' . DS, ), 'URL_MODE' => 'PATH', 'URL_GREEDY' => false, 'DEBUG_SHOW_TRACE' => true, 'DEBUG_SHOW_ERROR' => true, 'DEBUG_SHOW_EXCEPTION' => true, 'DEBUG_LOG' => false, 'TPL_SUFFIX' => 'php', 'URL_ROUTE_RULES' => array( ), ) , self::$_config ); ArApp::run(); } static public function setA($key, $val) { $classkey = strtolower($key); self::$_a[$classkey] = $val; } static public function getConfig($ckey = '', $defaultReturn = array()) { $rt = array(); if (empty($ckey)) : $rt = self::$_config; else : if (strpos($ckey, '.') === false) : if (isset(self::$_config[$ckey])) : $rt = self::$_config[$ckey]; else : if (func_num_args() > 1) : $rt = $defaultReturn; else : $rt = null; endif; endif; else : $cE = explode('.', $ckey); $rt = self::$_config; while (($k = array_shift($cE)) || is_numeric($k)) : if (!isset($rt[$k])) : if (func_num_args() > 1) : $rt = $defaultReturn; else : $rt = null; endif; break; else : $rt = $rt[$k]; endif; endwhile; endif; endif; return $rt; } static public function setConfig($ckey = '', $value = array()) { if (!empty($ckey)) : if (strpos($ckey, '.') === false) : self::$_config[$ckey] = $value; else : $cE = explode('.', $ckey); $rt = self::$_config; $nowArr = array(); $length = count($cE); for ($i = $length - 1; $i >= 0; $i--) : if ($i == $length - 1) : $nowArr = array($cE[$i] => $value); else : $tem = $nowArr; $nowArr = array(); $nowArr[$cE[$i]] = $tem; endif; endfor; self::$_config = arComp('format.format')->arrayMergeRecursiveDistinct( self::$_config, $nowArr ); endif; else : self::$_config = $value; endif; } static public function a($akey) { $akey = strtolower($akey); return isset(self::$_a[$akey]) ? self::$_a[$akey] : null; } static public function c($cname) { $cKey = strtolower($cname); if (!isset(self::$_c[$cKey])) : $config = self::getConfig('components.' . $cKey . '.config', array()); self::setC($cKey, $config); endif; return self::$_c[$cKey]; } static public function setC($component, array $config = array()) { $cKey = strtolower($component); if (isset(self::$_c[$cKey])) : return false; endif; $cArr = explode('.', $component); array_unshift($cArr, 'components'); $cArr = array_map('ucfirst', $cArr); $className = 'Ar' . array_pop($cArr); $cArr[] = $className; $classFile = implode($cArr, '\\'); self::$_c[$cKey] = call_user_func_array("$className::init", array($config, $className)); } static public function autoLoader($class) { $class = str_replace('\\', DS, $class); if (AR_OUTER_START) : $appModule = AR_MAN_PATH; else : $appModule = AR_ROOT_PATH . DS . arCfg('requestRoute.a_m', AR_DEFAULT_APP_NAME) . DS; endif; array_push(self::$autoLoadPath, $appModule); if (preg_match("#[A-Z]{1}[a-z0-9]+$#", $class, $match)) : $appEnginePath = $appModule . $match[0] . DS; $extPath = $appModule . 'Ext' . DS; $binPath = $appModule . 'Bin' . DS; $protocolPath = $appModule . 'Protocol' . DS; array_push(self::$autoLoadPath, $appEnginePath, $extPath, $binPath, $protocolPath); endif; self::$autoLoadPath = array_unique(self::$autoLoadPath); foreach (self::$autoLoadPath as $path) : $classFile = $path . $class . '.class.php'; if (is_file($classFile)) : include_once $classFile; $rt = true; break; endif; endforeach; if (empty($rt)) : if (AR_AS_OUTER_FRAME || AR_OUTER_START) : return false; else : trigger_error('class : ' . $class . ' does not exist !', E_USER_ERROR); exit; endif; endif; } static public function importPath($path) { array_unshift(self::$autoLoadPath, rtrim($path, DS) . DS); } static public function import($path, $allowTry = false) { static $holdFile = array(); if (strpos($path, DS) === false) : $fileName = str_replace(array('c.', 'ext.', 'app.', '.'), array('Controller.', 'Extensions.', rtrim(AR_ROOT_PATH, DS) . '.', DS), $path) . '.class.php'; else : $fileName = $path; endif; if (is_file($fileName)) : if (substr($fileName, (strrpos($fileName, '.') + 1)) == 'ini') : $config = parse_ini_file($fileName, true); if (empty($config)) : $config = array(); endif; return $config; else : $file = include_once $fileName; if ($file === true) : return $holdFile[$fileName]; else : $holdFile[$fileName] = $file; return $file; endif; endif; else : if ($allowTry) : return array(); else : throw new ArException('import not found file :' . $fileName); endif; endif; } static public function exceptionHandler($e) { if (get_class($e) === 'ArServiceException') : arComp('rpc.service')->response(array('error_code' => '1001', 'error_msg' => $e->getMessage())); exit; endif; if (AR_DEBUG && !AR_AS_CMD) : $msg = '<b style="color:#ec8186;">' . get_class($e) . '</b> : ' . $e->getMessage(); if (arCfg('DEBUG_SHOW_TRACE')) : arComp('ext.out')->deBug($msg, 'TRACE'); else : if (arCfg('DEBUG_SHOW_EXCEPTION')) : arComp('ext.out')->deBug($msg, 'EXCEPTION'); endif; endif; endif; } static public function errorHandler($errno, $errstr, $errfile, $errline) { if (AR_RUN_AS_SERVICE_HTTP) : arComp('rpc.service')->response(array('error_code' => '1011', 'error_msg' => $errstr)); exit; endif; if (!AR_DEBUG || !(error_reporting() & $errno)) : return; endif; $errMsg = ''; $serverError = false; switch ($errno) { case E_USER_ERROR: $errMsg .= "<b style='color:red;'>ERROR</b> [$errno] $errstr<br />\n"; $errMsg .= "  Fatal error on line $errline in file $errfile"; $errMsg .= ", PHP " . PHP_VERSION . " (" . PHP_OS . ")<br />\n"; $serverError = true; break; case E_USER_WARNING: $errMsg .= "<b style='color:#ec8186;'>WARNING</b> [$errno] $errstr<br />\n"; $errMsg .= " on line $errline in file $errfile <br />\n"; break; case E_USER_NOTICE: case E_NOTICE: $errMsg .= "<b style='color:#ec8186;'>NOTICE</b> [$errno] $errstr<br />\n"; $errMsg .= " on line $errline in file $errfile <br />\n"; break; default: $errMsg .= "<b style='color:#ec8186;'>Undefined error</b> : [$errno] $errstr"; $errMsg .= " on line $errline in file $errfile <br />\n"; break; } if ($errMsg) : if (arCfg('DEBUG_SHOW_TRACE')) : arComp('ext.out')->deBug($errMsg, 'TRACE'); else : if (arCfg('DEBUG_SHOW_ERROR')) : if ($serverError === true) : arComp('ext.out')->deBug($errMsg, 'SERVER_ERROR'); else : arComp('ext.out')->deBug($errMsg, 'ERROR'); endif; endif; endif; endif; return true; } public static function shutDown() { if (AR_RUN_AS_SERVICE_HTTP) : return; endif; if (AR_DEBUG && !AR_AS_CMD) : if (arCfg('DEBUG_SHOW_EXCEPTION')) : arComp('ext.out')->deBug('', 'EXCEPTION', true); endif; if (arCfg('DEBUG_SHOW_ERROR')) : arComp('ext.out')->deBug('', 'ERROR', true); arComp('ext.out')->deBug('', 'SERVER_ERROR', true); endif; if (arCfg('DEBUG_SHOW_TRACE')) : arComp('ext.out')->deBug('[SHUTDOWN]', 'TRACE', true); endif; endif; } } 
 class ArApp { static public function run() { if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('[APP_RUN]'); endif; self::_initComponents(Ar::getConfig('components', array())); if (AR_OUTER_START) : return; endif; if (AR_RUN_AS_SERVICE_HTTP) : $app = self::_createWebApplication('ArApplicationServiceHttp'); $app->start(); elseif (AR_AS_CMD) : $app = self::_createWebApplication('ArApplicationCmd'); $app->start(); elseif (AR_AS_WEB) : $app = self::_createWebApplication('ArApplicationWeb'); $app->start(); endif; } static private function _initComponents(array $config) { foreach ($config as $driver => $component) : if (!is_array($component)) : continue; endif; if (empty($component['lazy']) || $component['lazy'] == true) : continue; endif; foreach ($component as $engine => $cfg) : if (!empty($cfg['lazy']) && $cfg['lazy'] == true || $engine == 'lazy') : continue; endif; $configC = !empty($cfg['config']) ? $cfg['config'] : array(); Ar::setC($driver . '.' . $engine, $configC); endforeach; endforeach; } static private function _createWebApplication($class) { $classkey = strtolower($class); if (!Ar::a($classkey)) : Ar::setA($classkey, new $class); endif; return Ar::a($classkey); } } 
 class ArApplicationSocket extends ArApplicationCmd { public function start() { } }
 abstract class ArApplication { public abstract function start(); } 
 class ArApplicationCmd extends ArApplication { public function start() { ArWorker::startAll(); } } class ArWorker { const VERSION = '2.0.1'; const STATUS_STARTING = 1; const STATUS_RUNNING = 2; const STATUS_SHUTDOWN = 4; const STATUS_RELOADING = 8; protected static $_status = self::STATUS_STARTING; public static $workers = array(); public static $pids = array(); public static $event = array(); public static $connections = array(); public $workerCount = 1; public $protocol = null; protected static $masterPidFile; protected static $masterPid; protected static $daemonize = false; private static $_globalStatistics = array( 'start_timestamp' => 0, 'worker_exit_info' => array() ); private static $_statisticsFile; public $serverSocket; public $onMessage = null; public $onStart = null; public $onStop = null; public $onClose = null; public $onError = null; public $onConnect = null; public $config = null; public function __construct($socketName = 'ar_worker', $contextOption = array()) { $this->workerId = spl_object_hash($this); self::$workers[$this->workerId] = $this; self::$pids[$this->workerId] = array(); $backrace = debug_backtrace(); $this->appInitPath = dirname($backrace[0]['file']); $this->socketName = strtolower(trim($socketName)); $this->context = stream_context_create($contextOption); $this->config = arCfg($socketName); } public static function startAll() { ini_set('opcache.enable', false); self::$_globalStatistics['start_timestamp'] = time(); self::$_statisticsFile = sys_get_temp_dir() . '/ArPHPServer.status'; self::checkEnv(); self::$masterPidFile = AR_CMD_PATH . 'master.pid'; self::parseCommand(); self::loadFile(); echo 'started' . "\n"; if (self::$daemonize) : self::deamon(); endif; self::saveMasterPid(); self::setProcessTitle('AR MASTER PROCESS '); self::init(); } public static function loadFile() { foreach(glob(AR_CMD_PATH . 'Model/*.php') as $workerStartFile) : require_once $workerStartFile; endforeach; foreach(glob(AR_CMD_PATH . 'Module/*.php') as $workerStartFile) : require_once $workerStartFile; endforeach; foreach(glob(AR_CMD_PATH . 'Protocol/*.php') as $workerStartFile) : require_once $workerStartFile; endforeach; foreach(glob(AR_CMD_PATH . 'Worker/*.php') as $workerStartFile) : require_once $workerStartFile; endforeach; foreach(glob(AR_CMD_PATH . 'Lib/*.php') as $workerStartFile) : require_once $workerStartFile; endforeach; $workerFiles = glob(AR_CMD_PATH . 'Bin/*_worker.php'); if (!empty($workerFiles)) : foreach($workerFiles as $workerStartFile) : require_once $workerStartFile; endforeach; else : exit('has none worker has been seted' . "\n"); endif; } public function checkEnv() { if (!extension_loaded('pcntl')) : exit("Please install pcntl extension.\n"); endif; if (!extension_loaded('posix')) : exit("Please install posix extension.\n"); endif; if (!extension_loaded('libevent')) : exit("Please install libevent extension.\n"); endif; } public static function init() { self::$_status = self::STATUS_STARTING; self::installSignal(); self::forkWorkers(); self::monitorWorkers(); } public static function parseCommand() { global $argv; $start_file = $argv[0]; if (!isset($argv[1])) : exit("Usage: php yourfile.php {start|stop|restart|status}\n"); endif; $command = trim($argv[1]); $command2 = isset($argv[2]) ? $argv[2] : ''; $masterPid = @file_get_contents(self::$masterPidFile); $masterIsAlive = $masterPid && @posix_kill($masterPid, 0); if ($masterIsAlive) : if ($command === 'start') : echo 'arphp tcp server has running yet ' . "\n"; exit(0); elseif ($command === 'restart') : echo 'stopping...' . "\n"; $masterPid && posix_kill($masterPid, SIGINT); echo 'stopped' . "\n"; sleep(1); endif; elseif ($command === 'stop') : exit('server not running' . "\n"); endif; switch ($command) { case 'start': case 'restart': echo 'ArPHP Tcp Server starting...' . "\n"; if ($command2 == '-d') : self::$daemonize = true; endif; break; case 'status': if (is_file(self::$_statisticsFile)) : @unlink(self::$_statisticsFile); endif; posix_kill($masterPid, SIGUSR2); usleep(100000); readfile(self::$_statisticsFile); exit(0); case 'stop': echo 'stopping...' . "\n"; $masterPid && posix_kill($masterPid, SIGINT); echo 'stopped' . "\n"; exit(0); default : exit("Usage: php yourfile.php {start|stop|restart|status}\n"); } } public static function deamon() { umask(0); $pid = pcntl_fork(); if ($pid == -1) : throw new ArExceptionCmd("fork faild", 1200); endif; if ($pid > 0) : exit(0); else : if (posix_setsid() == -1) : throw new ArExceptionCmd("set leader sid faild", 1201); endif; $pid = pcntl_fork(); if ($pid == -1) : throw new ArExceptionCmd("fork faild", 1200); endif; if ($pid > 0) : exit(0); endif; global $STDOUT, $STDERR; $stdoutFile = '/dev/null'; $handle = fopen($stdoutFile, "a"); if ($handle) : unset($handle); @fclose(STDOUT); @fclose(STDERR); $STDOUT = fopen($stdoutFile, "a"); $STDERR = fopen($stdoutFile, "a"); else : throw new ArExceptionCmd('can not open stdoutFile ' . $stdoutFile); endif; endif; } protected static function saveMasterPid() { self::$masterPid = posix_getpid(); if (false === @file_put_contents(self::$masterPidFile, self::$masterPid)) : throw new Exception('can not save pid to ' . self::$masterPidFile); endif; } protected static function writeStatisticsToStatusFile() { if (self::$masterPid === posix_getpid()) : $loadavg = sys_getloadavg(); file_put_contents(self::$_statisticsFile, "--------------------------------ArPHPServer GLOBAL STATUS-----------------------------------------\n"); file_put_contents(self::$_statisticsFile, "PHP version:" . PHP_VERSION."\n", FILE_APPEND); file_put_contents(self::$_statisticsFile, 'start time:'. date('Y-m-d H:i:s', self::$_globalStatistics['start_timestamp']).'   run ' . floor((time()-self::$_globalStatistics['start_timestamp'])/(24*60*60)). ' days ' . floor(((time()-self::$_globalStatistics['start_timestamp'])%(24*60*60))/(60*60)) . " hours   \n", FILE_APPEND); file_put_contents(self::$_statisticsFile, 'load average: ' . implode(", ", $loadavg) . "\n", FILE_APPEND); file_put_contents(self::$_statisticsFile, count(self::$pids) . ' workers       ' . count(self::getAllWorkerPids())." processes\n", FILE_APPEND); file_put_contents(self::$_statisticsFile, "---------------------------------------PROCESS STATUS-------------------------------------------\n", FILE_APPEND); file_put_contents(self::$_statisticsFile, "pid\tmemory " . str_pad('worker_name', 9)." connections ".str_pad('total_request', 12) . " " . str_pad('send_fail', 9)." ".str_pad('throw_exception', 15)."\n", FILE_APPEND); chmod(self::$_statisticsFile, 0722); foreach (self::getAllWorkerPids() as $workerPid) : posix_kill($workerPid, SIGUSR2); endforeach; return; endif; $worker = current(self::$workers); $wrker_status_str = posix_getpid()."\t".str_pad(round(memory_get_usage()/(1024*1024),2)."M", 7)." " .str_pad($worker->socketName, 9); $wrker_status_str .= str_pad(ArTcpConnection::$statistics['connection_count'], 12)." ".str_pad(ArTcpConnection::$statistics['total_request'], 12)." ".str_pad(ArTcpConnection::$statistics['send_fail'], 9) . " " . str_pad(ArTcpConnection::$statistics['throw_exception'], 15) . "\n"; file_put_contents(self::$_statisticsFile, $wrker_status_str, FILE_APPEND); } protected static function installSignal() { pcntl_signal(SIGINT, array('ArWorker', 'signalHandler'), false); pcntl_signal(SIGUSR1, array('ArWorker', 'signalHandler'), false); pcntl_signal(SIGUSR2, array('ArWorker', 'signalHandler'), false); pcntl_signal(SIGPIPE, SIG_IGN, false); } protected static function reinstallSignal() { pcntl_signal(SIGINT, SIG_IGN, false); pcntl_signal(SIGUSR1, SIG_IGN, false); pcntl_signal(SIGUSR2, SIG_IGN, false); self::$event->add(SIGINT, 'SIGNAL', array('ArWorker', 'signalHandler')); self::$event->add(SIGUSR1, 'SIGNAL', array('ArWorker', 'signalHandler')); self::$event->add(SIGUSR2, 'SIGNAL', array('ArWorker', 'signalHandler')); } public static function signalHandler($signal) { switch($signal) { case SIGINT: self::stopAll(); break; case SIGUSR1: break; case SIGUSR2: self::writeStatisticsToStatusFile(); break; } } public static function stopAll() { self::$_status = self::STATUS_SHUTDOWN; if (self::$masterPid === posix_getpid()) : $worker_pid_array = self::getAllWorkerPids(); foreach ($worker_pid_array as $worker_pid) : posix_kill($worker_pid, SIGINT); ArTimer::add(1, 'posix_kill', array($worker_pid, SIGKILL), false); endforeach; else : foreach (self::$workers as $worker) : $worker->stop(); endforeach; endif; } public function stop() { if ($this->onStop) : try { call_user_func($this->onStop, $this); } catch (Exception $e) { echo $e->getMessage(); arComp('list.log')->record($e->getMessage(), 'errorstop'); } endif; self::$event->del($this->serverSocket, 'READ'); @fclose($this->serverSocket); exit(0); } protected static function getAllWorkerPids() { $pidArray = array(); foreach(self::$pids as $workerPidArray) : foreach ($workerPidArray as $workerPid) : $pidArray[$workerPid] = $workerPid; endforeach; endforeach; return $pidArray; } public function run() { self::$event = new ArEvent(); self::reinstallSignal(); if ($this->serverSocket) : self::$event->add($this->serverSocket, 'READ', array($this, 'acceptConnection')); endif; ArTimer::init(self::$event); if ($this->onStart) : try { call_user_func($this->onStart, $this); } catch (Exception $e) { exit($e->getMessage()); } endif; self::$event->loop(); exit(500); } protected static function setProcessTitle($title) { if (function_exists('cli_set_process_title')) : @cli_set_process_title($title); elseif (extension_loaded('proctitle') && function_exists('setproctitle')) : @setproctitle($title); endif; } public function listen($ip = '', $port = '') { if (empty($ip)) : $ip = arCfg($this->socketName . '.listen_ip', '0.0.0.0'); endif; if (empty($port)) : $port = arCfg($this->socketName . '.listen_port'); endif; if ($ip && $port) : $this->serverSocket = stream_socket_server('tcp://'. $ip . ':' . $port, $errno, $errstr); if (!$this->serverSocket) die("$errstr ($errno)"); stream_set_blocking($this->serverSocket, 0); if (self::$event) : self::$event->add($this->serverSocket, 'READ', array($this, 'acceptConnection')); endif; endif; } protected static function forkWorkers() { foreach (self::$workers as $worker) : if (self::$_status === self::STATUS_STARTING) : $worker->listen(); endif; while(count(self::$pids[$worker->workerId]) < $worker->workerCount) : self::forkOneWorker($worker); endwhile; endforeach; } public static function forkOneWorker($worker) { $pid = pcntl_fork(); if ($pid < 0) : die('can not fork' . "\n"); elseif ($pid === 0) : self::$pids = array(); self::$workers = array($worker->workerId => $worker); self::setProcessTitle('AR WORKERP ROCESS : ' . $worker->socketName); $worker->run(); else : self::$pids[$worker->workerId][$pid] = $pid; endif; } protected static function monitorWorkers() { self::$_status = self::STATUS_RUNNING; while (true) : pcntl_signal_dispatch(); $status = 0; $pid = pcntl_wait($status, WUNTRACED); if ($pid > 0) : foreach (self::$pids as $workerId => $workerPidArray) : if (isset($workerPidArray[$pid])) : $worker = self::$workers[$workerId]; unset(self::$pids[$workerId][$pid]); if (self::$_status !== self::STATUS_SHUTDOWN) : arComp('list.log')->record("worker[".$worker->socketName.":$pid] exit with status $status", 'worker_exit'); self::forkWorkers(); endif; break; endif; endforeach; endif; if (self::$_status === self::STATUS_SHUTDOWN && !self::getAllWorkerPids()) : self::exitAndClearAll(); endif; endwhile; } protected static function exitAndClearAll() { @unlink(self::$masterPidFile); exit(0); } public function acceptConnection($socketServer) { var_dump('con'); $clientSocket = @stream_socket_accept($socketServer); if (false === $clientSocket) : return; endif; $tcpConnection = new ArTcpConnection($clientSocket); $tcpConnection->worker = $this; self::$connections[(int)$clientSocket] = $tcpConnection; stream_set_blocking($clientSocket, 0); if ($this->onConnect) : try { echo 'onConnect'; call_user_func($this->onConnect, $tcpConnection); } catch(Exception $e) { echo $e->getMessage(); arComp('list.log')->record($e->getMessage(), 'exceptionconnect'); ArTcpConnection::$statistics['throw_exception']++; } endif; echo 'connect'; } public function timer() { echo 'timer start'; } } class ArTcpConnection { const STATUS_CONNECTING = 1; const STATUS_ESTABLISH = 2; const STATUS_CLOSING = 4; const STATUS_CLOSED = 8; protected $_status = self:: STATUS_CONNECTING; protected $readBuffer = ''; protected $writeBuffer = ''; protected $clientSocket = null; protected $remoteIp = ''; protected $remotePort = 0; public $remoteAddress = ''; public static $maxSendBufferSize = 1048576; public static $statistics = array( 'connection_count' => 0, 'total_request' => 0, 'throw_exception' => 0, 'send_fail' => 0, ); public function __construct($clientSocket) { self::$statistics['connection_count']++; $this->_status = self::STATUS_ESTABLISH; $this->clientSocket = $clientSocket; ArWorker::$event->add($clientSocket, 'READ', array($this, 'read'), null, 10); } public function getRemoteIp() { if(!$this->remoteIp) { $this->remoteAddress = stream_socket_get_name($this->clientSocket, true); if($this->remoteAddress) { list($this->remoteIp, $this->remotePort) = explode(':', $this->remoteAddress, 2); $this->remotePort = (int)$this->remotePort; } } return $this->remoteIp; } public function getRemotePort() { if(!$this->remotePort) { $this->remoteAddress = stream_socket_get_name($this->clientSocket, true); if($this->remoteAddress) { list($this->remoteIp, $this->remotePort) = explode(':', $this->remoteAddress, 2); $this->remotePort = (int)$this->remotePort; } } return $this->remotePort; } public function consumeRecvBuffer($length) { $this->readBuffer = substr($this->readBuffer, $length); } public function read($client) { $fdKey = (int)$client; while(($buffer = fread($client, 8192)) || is_numeric($buffer)) : $this->readBuffer .= $buffer; endwhile; if ($this->readBuffer !== '') : if (!$this->worker->onMessage) : $this->readBuffer = ''; return; endif; while ($this->readBuffer !== '') { if (feof($client)) : $this->close(); return; endif; if ($protocol = $this->worker->protocol) : $length = call_user_func($protocol . '::input', $this->readBuffer, $this); if ($length === 0) : break; else : if ($length > 0 && $length <= self::$maxSendBufferSize) : if ($length > strlen($this->readBuffer)) : break; endif; else : arComp('list.log')->record(time(), 'error_package_length'); $this->close(); return; endif; self::$statistics['total_request']++; $message = substr($this->readBuffer, 0, $length); $message = call_user_func($protocol . '::decode', $message, $this); $this->readBuffer = substr($this->readBuffer, $length); if ($message === false) : $this->close(); else : if ($this->worker->onMessage) : try { call_user_func($this->worker->onMessage, $message, $this); } catch(Exception $e) { echo $e->getMessage(); arComp('list.log')->record($e->getMessage(), 'readprotocol'); self::$statistics['throw_exception']++; } endif; endif; endif; else : self::$statistics['total_request']++; if ($this->worker->onMessage) : try { call_user_func($this->worker->onMessage, $this->readBuffer, $this); } catch(Exception $e) { echo $e->getMessage(); arComp('list.log')->record($e->getMessage(), 'readnoprotocol'); self::$statistics['throw_exception']++; } endif; $this->readBuffer = ''; endif; } else : if (feof($client)) : $this->close(); endif; endif; } public function write() { if ($this->writeBuffer !== '') : $length = @fwrite($this->clientSocket, $this->writeBuffer); $bufferLength = strlen($this->writeBuffer); if ($length === $bufferLength) : ArWorker::$event->del($this->clientSocket, 'WRITE'); $this->writeBuffer = ''; if ($this->_status == self::STATUS_CLOSING) : $this->destruct(); endif; return true; elseif ($length > 0) : $this->writeBuffer = substr($this->writeBuffer, $length); else : if (feof($this->clientSocket)) : self::$statistics['send_fail']++; $this->destruct(); endif; endif; endif; } public function close($data = null, $closeForce = false) { if ($data !== null) : $this->send($data); endif; $this->_status = self::STATUS_CLOSING; if ($this->writeBuffer === '' || $closeForce) : $this->destruct(); endif; } public function send($message, $raw = false) { if ($this->_status == self::STATUS_CLOSED) : return false; endif; if ($raw === false && $protocol = $this->worker->protocol) : $message = call_user_func($protocol . '::encode', $message, $this); endif; if ($this->writeBuffer === '') : $fdKey = (int)$this->clientSocket; $bufferLength = strlen($message); $length = @fwrite($this->clientSocket, $message); if ($length === $bufferLength) : return true; elseif ($length > 0) : $this->writeBuffer = substr($message, $length); else : if (!is_resource($this->clientSocket) || feof($this->clientSocket)) : self::$statistics['send_fail']++; $this->close(); return false; endif; endif; ArWorker::$event->add($this->clientSocket, 'WRITE', array($this, 'write')); return null; else : if (self::$maxSendBufferSize <= strlen($this->writeBuffer) + strlen($message)) : self::$statistics['send_fail']++; arComp('list.log')->record('cs:' . (strlen($this->writeBuffer) + strlen($message)) . '>' . self::$maxSendBufferSize . ' msg : ' . $message, 'msg_full' . __FUNCTION__); if ($this->worker->onError) : call_user_func($this->worker->onError, $this); endif; return false; endif; $this->writeBuffer .= $message; endif; } public function destruct() { if ($this->worker->onClose) : try { call_user_func($this->worker->onClose, $this); } catch (Exception $e) { arComp('list.log')->record($e->getMessage(), 'exceptionclose'); self::$statistics['throw_exception']++; } endif; if ($this->_status !== self::STATUS_CLOSED) : self::$statistics['connection_count']--; $fdKey = (int)$this->clientSocket; fclose($this->clientSocket); unset(ArWorker::$connections[$fdKey]); ArWorker::$event->del($this->clientSocket, 'READ'); ArWorker::$event->del($this->clientSocket, 'WRITE'); $this->_status = self::STATUS_CLOSED; endif; echo 'closed' . "\n"; } } class ArEvent { public static $eventBase = null; protected static $allEvents = array(); protected static $eventSignal = array(); protected static $eventTimer = array(); public function __construct() { self::$eventBase = event_base_new(); } public function add($fd, $flag, $callBack, $args = null) { $fdKey = (int)$fd; switch ($flag) { case 'SIGNAL': $realFlag = EV_SIGNAL | EV_PERSIST; $this->eventSignal[$fdKey] = event_new(); if (!event_set($this->eventSignal[$fdKey], $fd, $realFlag, $callBack, null)) : return false; endif; if (!event_base_set($this->eventSignal[$fdKey], self::$eventBase)) : return false; endif; if (!event_add($this->eventSignal[$fdKey])) : return false; endif; return true; break; case 'TIMER': case 'TIMER_ONCE': $event = event_new(); $timerId = (int)$event; if (!event_set($event, 0, EV_TIMEOUT, array($this, 'timerCallback'), $timerId)) : echo 'af1'; return false; endif; if (!event_base_set($event, self::$eventBase)) : echo 'af2'; return false; endif; $timeInterval = $fd * 1000000; if (!event_add($event, $timeInterval)) : echo 'af3'; return false; endif; self::$eventTimer[$timerId] = array($callBack, (array)$args, $event, $flag, $timeInterval); return $timerId; break; case 'READ': case 'WRITE': $fdKey = (int)$fd; $realFlag = $flag == 'READ' ? EV_READ | EV_PERSIST : EV_WRITE | EV_PERSIST; $event = event_new(); if (!event_set($event, $fd, $realFlag, $callBack, null)) : return false; endif; if (!event_base_set($event, self::$eventBase)) : return false; endif; if (!event_add($event)) : return false; endif; $this->allEvents[$fdKey][$flag] = $event; return true; break; } } public function del($fd ,$flag) { switch($flag) { case 'READ': case 'WRITE': $fdKey = (int)$fd; if (isset($this->allEvents[$fdKey][$flag])) : event_del($this->allEvents[$fdKey][$flag]); unset($this->allEvents[$fdKey][$flag]); endif; if (empty($this->allEvents[$fdKey])) : unset($this->allEvents[$fdKey]); endif; break; case 'SIGNAL': $fdKey = (int)$fd; if (isset(self::$eventSignal[$fdKey])) : event_del(self::$eventSignal[$fdKey]); unset(self::$eventSignal[$fdKey]); endif; break; case 'TIMER': case 'TIMER_ONCE': if (isset(self::$eventTimer[$fd])) : event_del(self::$eventTimer[$fd][2]); unset(self::$eventTimer[$fd]); endif; break; } return true; } protected function timerCallback($_null, $_null, $timerId) { if (self::$eventTimer[$timerId][3] == 'TIMER') : event_add(self::$eventTimer[$timerId][2], self::$eventTimer[$timerId][4]); endif; try { call_user_func_array(self::$eventTimer[$timerId][0], self::$eventTimer[$timerId][1]); } catch(Exception $e) { echo $e->getMessage(); } } public function clearAllArTimer() { foreach (self::$eventTimer as $task_data) : event_del($task_data[2]); endforeach; self::$eventTimer = array(); } public function loop() { event_base_loop(self::$eventBase); } } class ArTimer { protected static $_event = null; protected static $_tasks = array(); public static function init($event = null) { if ($event) : self::$_event = $event; endif; } public static function del($timer_id) { if(self::$_event) { return self::$_event->del($timer_id, 'TIMER'); } } public static function add($time_interval, $func, $args = array(), $persistent = true) { if($time_interval <= 0) { echo new Exception("bad time_interval"); return false; } if(self::$_event) { return self::$_event->add($time_interval, $persistent ? 'TIMER' : 'TIMER_ONCE', $func, $args); } } } class ArProtocolText { public static function input($buffer, $connection) { $pos = strpos($buffer, "\n"); if($pos === false) { return 0; } return $pos + 1; } public static function encode($buffer, $connection) { return $buffer . "\n"; } public static function decode($buffer, $connection) { return trim($buffer); } } class ArContext { static private $_holder = array(); public static function get($key) { if (array_key_exists($key, self::$_holder)) : return self::$_holder[$key]; else : return null; endif; } public static function set($key, $value) { self::$_holder[$key] = $value; } public static function flush() { self::$_holder = array(); } } 
 class ArApplicationService extends ArApplication { public function start() { } } 
 class ArApplicationServiceHttp extends ArApplicationService { public function start() { $data = $this->parseHttpServiceHanlder(); return $this->runService($data); } public function parseHttpServiceHanlder() { if ($ws = arPost('ws')) : if (!$ws = arComp('rpc.api')->decrypt($ws)) : throw new ArServiceException('ws query format incorrect error'); endif; if (empty($ws['class']) || empty($ws['method']) || !isset($ws['param'])) : throw new ArServiceException('ws query param missing error'); endif; return array( 'class' => $ws['class'], 'method' => $ws['method'], 'param' => $ws['param'], ); else : throw new ArServiceException('ws query ws info missing error'); endif; } protected function runService($ws = array()) { $service = $ws['class'] . 'Service'; $method = $ws['method'] . 'Worker'; $param = $ws['param']; try { $serviceHolder = new $service; $serviceHolder->init(); if (!is_callable(array($serviceHolder, $method))) : throw new ArServiceException('ws service do not hava a method ' . $method); endif; return call_user_func_array(array($serviceHolder, $method), $param); } catch(Exception $e) { throw new ArServiceException($e->getMessage()); } } } 
 class ArApplicationWeb extends ArApplication { public $route = array(); public function start() { if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('[APP_WEB_START]'); endif; if (AR_AUTO_START_SESSION && ini_get('session.auto_start') == 0) : session_start(); endif; $this->processRequest(); } public function processRequest() { $this->runController(Ar::getConfig('requestRoute')); } public function runController($route) { if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('[CONTROLLER_RUN]'); endif; Ar::setConfig('requestRoute', $route); if (empty($route['a_c'])) : $c = 'Index'; else : $c = ucfirst($route['a_c']); endif; $this->route['a_c'] = $c; $class = $c . 'Controller'; if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('|CONTROLLER_EXEC:'. $class .'|'); endif; if (class_exists($class)) : $this->_c = new $class; $this->_c->init(); $action = ($a = empty($route['a_a']) ? AR_DEFAULT_ACTION : $route['a_a']) . 'Action'; $this->route['a_a'] = $a; if (is_callable(array($this->_c, $action))) : try { if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('|ACTION_RUN:' . $action . '|'); endif; $this->_c->$action(); if (AR_AS_OUTER_FRAME) : exit; endif; } catch (ArException $e) { if (!AR_AS_OUTER_FRAME) : throw new ArException($e->getMessage()); endif; } else : if (!AR_AS_OUTER_FRAME) : throw new ArException('Action ' . $action . ' not found'); endif; endif; endif; } } 
 class ArController { protected $assign = array(); protected $layOutFile = 'NOT_INIT'; public function init() { } public function __call($name, $params) { $mName = empty($params[0]) ? arCfg('requestRoute.a_c') : $params[0]; if ($name == 'module') : return arModule($mName); elseif ($name == 'model') : $m = $mName . 'Model'; return ArModel::model($m); else : throw new ArException("class do not have a method $name"); endif; } public function assign(array $vals) { foreach ($vals as $key => $val) : if (is_array($val) && isset($this->assign[$key]) && is_array($this->assign[$key])) : $this->assign[$key] = array_merge($this->assign[$key], $val); else : $this->assign[$key] = $val; endif; endforeach; } public function show($ckey = '', $defaultReturn = '', $show = true) { $rt = array(); if (empty($ckey)) : $rt = $this->assign; else : if (strpos($ckey, '.') === false) : if (isset($this->assign[$ckey])) : $rt = $this->assign[$ckey]; endif; else : $cE = explode('.', $ckey); $rt = $this->assign; while ($k = array_shift($cE)) : if (empty($rt[$k])) : $rt = $defaultReturn; break; else : $rt = $rt[$k]; endif; endwhile; endif; endif; if ($show) : echo $rt; else : return $rt; endif; } protected function display($view = '', $fetch = false) { $headerFile = ''; $footerFile = ''; if ($this->layOutFile === 'NOT_INIT') : $headerFile = AR_APP_VIEW_PATH . 'Layout' . DS . 'header' . '.' . arCfg('TPL_SUFFIX'); $footerFile = AR_APP_VIEW_PATH . 'Layout' . DS . 'footer' . '.' . arCfg('TPL_SUFFIX'); elseif ($this->layOutFile) : $headerFile = $this->layOutFile . '_header' . '.' . arCfg('TPL_SUFFIX'); $footerFile = $this->layOutFile . '_footer' . '.' . arCfg('TPL_SUFFIX'); endif; if ($headerFile) : if (is_file($headerFile)) : $this->fetch($headerFile); else : if ($this->layOutFile !== 'NOT_INIT') : throw new ArException("not fount layout header file : " . $headerFile, '2000'); endif; endif; endif; $this->fetch($view, $fetch); if ($footerFile) : if (is_file($footerFile)) : $this->fetch($footerFile); else : if ($this->layOutFile !== 'NOT_INIT') : throw new ArException("not fount layout footer file : " . $footerFile, '2000'); endif; endif; endif; if ($fetch === false) : exit; endif; } protected function fetch($view = '', $fetch = false) { if (is_file($view)) : $viewFile = $view; else : $viewPath = ''; $viewBasePath = arCfg('PATH.VIEW'); $overRide = false; $absolute = false; if (strpos($view, '@') === 0) : $overRide = true; $view = ltrim($view, '@'); endif; $r = Ar::a('ArApplicationWeb')->route; if (empty($view)) : $viewPath .= $r['a_c'] . DS . $r['a_a']; elseif(strpos($view, '/') !== false) : if (substr($view, 0, 1) == '/') : $absolute = true; $viewPath .= str_replace('/', DS, ltrim($view, '/')); else : $viewPath .= $r['a_c'] . DS . str_replace('/', DS, ltrim($view, '/')); endif; if (substr($view, -1) == '/') : $viewPath .= $r['a_a']; endif; else : $viewPath .= $r['a_c'] . DS . $view; endif; $currentC = $tempC = $r['a_c'] . 'Controller'; $preFix = ''; if (!$absolute) : while ($cP = get_parent_class($tempC)) : if (!in_array(substr($cP, 0, -10), array('Ar', 'Base'))) : $preFix = substr($cP, 0, -10) . DS . $preFix; if (!$overRide && method_exists($cP, $r['a_a'] . 'Action')) : $viewPath = str_replace(substr($tempC, 0, -10) . DS, '', $viewPath); endif; $tempC = $cP; else : break; endif; endwhile; endif; $viewFile = $viewBasePath . $preFix . $viewPath . '.' . arCfg('TPL_SUFFIX'); endif; if (is_file($viewFile)) : extract($this->assign); if ($fetch === true) : ob_start(); include $viewFile; $fetchStr = ob_get_contents(); ob_end_clean(); return $fetchStr; else : include $viewFile; endif; else : throw new ArException('view : ' . $viewFile . ' not found'); endif; } public function redirect($r = '', $show = '', $time = '0') { return arComp('url.route')->redirect($r, $show, $time, arCfg('SEG_REDIRECT_DEFAULT', 'default')); } public function redirectSuccess($r = '', $show = '', $time = '1') { return arComp('url.route')->redirect($r, '操作成功! ' . $show, $time, arCfg('SEG_REDIRECT_SUCCESS', 'success')); } public function redirectError($r = '', $show = '' , $time = '4') { return arComp('url.route')->redirect($r, '操作失败! ' . $show, $time, arCfg('SEG_REDIRECT_ERROR', 'error')); } public function showJsonSuccess($msg = ' ') { $this->showJson(array('ret_msg' => $msg, 'ret_code' => '1000', 'success' => "1")); } public function showJsonError($msg = ' ', $code = '1001') { $this->showJson(array('ret_msg' => $msg, 'ret_code' => $code, 'error_msg' => $msg, 'success' => "0")); } public function showJson($data = array(), array $options = array()) { return arComp('ext.out')->json($data, $options); } public function ifLogin() { return !!arComp('list.session')->get('uid'); } public function logOut() { arComp('list.session')->set('uid', null); } public function runController($module) { $route = explode('/', $module); $requestRoute = array( 'a_m' => arCfg('requestRoute.a_m'), 'a_c' => $route[0], 'a_a' => $route[1], ); Ar::a('ArApplicationWeb')->runController($requestRoute); } public function setLayoutFile($layoutFileName = '') { if ($layoutFileName) : if (!is_file($layoutFileName)) : $layoutFileName = AR_APP_VIEW_PATH . 'Layout' . DS . $layoutFileName; endif; endif; $this->layOutFile = $layoutFileName; } } 
 class ArDbException extends ArException { } 
 class ArExceptionCmd extends ArException { } 
 class ArHttpService { protected function response($data = '') { return arComp('rpc.service')->response($data); } public function init() { } } 
 class ArModel { public $nowModel = ''; public $tableName = ''; private static $_models = array(); static public function model($class = __CLASS__) { $key = strtolower($class); if (!isset(self::$_models[$key])) : if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('|MODEL_INIT:' . $class . '|'); endif; if (strlen($class) <= 5 || substr($class, '-5') !== 'Model') : $obj = new self; $obj->tableName = strtolower($class); else : $obj = new $class; endif; $obj->nowModel = $class; if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('|MODEL_START:' . $class . '|'); endif; self::$_models[$key] = $obj; else : if (AR_DEBUG && !AR_AS_CMD) : arComp('ext.out')->deBug('|MODEL_RESTART:' . $class . '|'); endif; endif; return self::$_models[$key]; } public function upload($field, $type = 'img') { $upFile = arComp('ext.upload')->upload($field, '', $type); if (!$upFile) : arComp('list.log')->set($this->nowModel, arComp('ext.upload')->errorMsg()); return false; else : return $upFile; endif; } public function getDb($dbType = 'mysql', $dbString = 'default', $read = true) { if ($read) : return ArComp('db.' . $dbType)->read($dbString)->table($this->tableName)->setSource($this->nowModel); else : return ArComp('db.' . $dbType)->write($dbString)->table($this->tableName)->setSource($this->nowModel); endif; } public function rules() { return array(); } public function updateCheck(array $data = array()) { $rules = $this->rules(); foreach ($rules as $key => $rule) : if (empty($rules[2]) || $rules[2] != 'update' ) : unset($rules[$key]); endif; endforeach; return $this->insertCheck($data, $rules); } public function insertCheck(array $data = array(), array $rules = array()) { $rules = empty($rules) ? $this->rules() : $rules; $r = arComp('validator.validator')->checkDataByRules($data, $rules); if (empty($r)) : return true; endif; $errorMsg = ''; foreach ($r as $errorR) : $errorMsg .= $errorR[1] . "\n"; endforeach; arComp('list.log')->set($this->nowModel, $errorMsg); return false; } public function formatData($data) { return $data; } } 
 class ArServiceException extends ArException { } 
/**Time(2016-05-27 17:44:15) - VerCode(150)*/